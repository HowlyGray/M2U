<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Messagerie P2P chiffrée de bout en bout pour des communications sécurisées">
    <meta name="theme-color" content="#4f46e5">
    <title>PeerText - Messagerie P2P Chiffrée</title>

    <!-- PWA -->
    <link rel="manifest" href="/manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="PeerText">

    <!-- PeerJS via jsDelivr (meilleur support des source maps) -->
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>

    <!-- Firebase SDK (pour découverte automatique des peers) -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: #16213e; /* Dégradé simplifié pour performance */
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            color: #fff;
        }

        /* Désactiver les animations pour les utilisateurs qui préfèrent moins de mouvement */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Focus states visibles pour accessibilité */
        *:focus-visible {
            outline: 2px solid #63b3ed;
            outline-offset: 2px;
        }

        button:focus-visible,
        input:focus-visible,
        textarea:focus-visible {
            box-shadow: 0 0 0 3px rgba(99, 179, 237, 0.3);
        }

        /* Screen reader only class for accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .container {
            width: 100%;
            max-width: 1100px;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(12px);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        header {
            background: rgba(11, 18, 39, 0.95);
            padding: 20px 25px;
            text-align: center;
            border-bottom: 1px solid rgba(99, 179, 237, 0.3);
            position: relative;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(to right, #63b3ed, #81e6d9, #f093fb);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: inline-flex;
            align-items: center;
            gap: 12px;
        }

        .subtitle {
            color: #94a3b8;
            font-size: 1rem;
            margin-top: 8px;
        }

        .badges {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .badge.e2e {
            background: rgba(52, 211, 153, 0.2);
            color: #34d399;
            border: 1px solid rgba(52, 211, 153, 0.3);
        }

        .badge.p2p {
            background: rgba(99, 179, 237, 0.2);
            color: #63b3ed;
            border: 1px solid rgba(99, 179, 237, 0.3);
        }

        .badge.files {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .badge.rooms {
            background: rgba(167, 139, 250, 0.2);
            color: #a78bfa;
            border: 1px solid rgba(167, 139, 250, 0.3);
        }

        /* Mobile menu button */
        .mobile-menu-btn {
            position: absolute;
            top: 20px;
            left: 25px;
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.8);
            color: #94a3b8;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .mobile-menu-btn:hover {
            background: rgba(51, 65, 85, 0.8);
            color: #e2e8f0;
        }

        .mobile-menu-btn:active {
            transform: scale(0.95);
        }

        /* Close button for mobile sidebar */
        .mobile-close-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.95);
            color: #94a3b8;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 102;
        }

        .mobile-close-btn:hover {
            background: rgba(51, 65, 85, 0.95);
            color: #e2e8f0;
        }

        /* Overlay for mobile sidebar */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 99;
            display: none;
        }

        .sidebar-overlay.show {
            display: block;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 280px 1fr;
            height: 100vh;
            max-height: 100vh;
            overflow: hidden;
        }

        .main-area {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            background: rgba(11, 18, 39, 0.8);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .sidebar-section h3 {
            color: #94a3b8;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .my-info {
            background: rgba(99, 179, 237, 0.1);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid rgba(99, 179, 237, 0.2);
        }

        .my-id {
            font-family: monospace;
            font-size: 0.9rem;
            color: #63b3ed;
            word-break: break-all;
            margin-bottom: 8px;
        }

        .copy-btn {
            width: 100%;
            padding: 8px;
            background: rgba(99, 179, 237, 0.2);
            border: 1px solid rgba(99, 179, 237, 0.3);
            color: #63b3ed;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: rgba(99, 179, 237, 0.3);
        }

        .input-field {
            width: 100%;
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(11, 22, 47, 0.7);
            color: white;
            font-size: 0.95rem;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .input-field:focus {
            outline: none;
            border-color: rgba(99, 179, 237, 0.6);
            box-shadow: 0 0 0 3px rgba(99, 179, 237, 0.15);
        }

        .input-field::placeholder {
            color: #64748b;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #5b52e8; /* Dégradé simplifié en couleur solide */
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4);
            background: #6d63f1;
        }

        .btn-secondary {
            background: rgba(30, 41, 59, 0.8);
            color: #94a3b8;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .btn-secondary:hover:not(:disabled) {
            background: rgba(51, 65, 85, 0.8);
            color: #cbd5e1;
        }

        .btn-success {
            background: #0ca678; /* Dégradé simplifié */
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #10b981;
        }

        .btn-danger {
            background: #e53e3e; /* Dégradé simplifié */
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #ef4444;
        }

        /* Peers list */
        .peers-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 20px;
            min-height: 0;
        }

        .peer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 10px;
            margin-bottom: 8px;
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.2s;
        }

        .peer-item:hover {
            background: rgba(30, 41, 59, 0.8);
        }

        .peer-item.connected {
            border-color: rgba(52, 211, 153, 0.3);
        }

        .peer-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(45deg, #4f46e5, #7c3aed);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        .peer-details {
            flex: 1;
            min-width: 0;
        }

        .peer-name {
            color: #e2e8f0;
            font-weight: 500;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .peer-status {
            font-size: 0.75rem;
            color: #64748b;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .peer-status.online {
            color: #34d399;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
        }

        .encryption-badge {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(52, 211, 153, 0.2);
            color: #34d399;
        }

        .role-badge {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 6px;
        }

        .role-badge.admin {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .role-badge.creator {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .peer-actions {
            display: flex;
            gap: 4px;
            margin-left: 8px;
        }

        .peer-action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #94a3b8;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .peer-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #e2e8f0;
        }

        /* Main chat area */
        .chat-area {
            display: flex;
            flex-direction: column;
            background: rgba(15, 23, 42, 0.5);
        }

        .chat-header {
            padding: 16px 20px;
            background: rgba(11, 18, 39, 0.8);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chat-header-info h2 {
            color: #e2e8f0;
            font-size: 1.1rem;
        }

        .chat-header-info .room-id {
            font-size: 0.8rem;
            color: #64748b;
            font-family: monospace;
        }

        .participants-count {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #94a3b8;
            font-size: 0.85rem;
        }

        .messages-container {
            flex: 1 1 auto;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            max-height: 100%;
            scroll-behavior: smooth;
        }

        .message {
            max-width: 75%;
            padding: 12px 16px;
            border-radius: 16px;
            position: relative;
            animation: fadeIn 0.3s ease;
            word-wrap: break-word;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.sent {
            background: linear-gradient(45deg, #4f46e5, #6366f1);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .message.received {
            background: rgba(30, 41, 59, 0.9);
            color: #e2e8f0;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }

        .message.system {
            background: rgba(30, 41, 59, 0.5);
            color: #94a3b8;
            align-self: center;
            max-width: 90%;
            font-size: 0.85rem;
            border-radius: 10px;
            text-align: center;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            gap: 12px;
        }

        .message-sender {
            font-weight: 600;
            font-size: 0.8rem;
            color: #81e6d9;
        }

        .message.sent .message-sender {
            color: rgba(255, 255, 255, 0.8);
        }

        .message-time {
            font-size: 0.7rem;
            opacity: 0.7;
        }

        .message-content {
            line-height: 1.4;
        }

        .message-encryption {
            font-size: 0.65rem;
            margin-top: 4px;
            opacity: 0.6;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* File message */
        .file-message {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 12px;
            margin-top: 8px;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: rgba(99, 179, 237, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #63b3ed;
        }

        .file-details {
            flex: 1;
        }

        .file-name {
            font-weight: 500;
            font-size: 0.9rem;
            word-break: break-all;
        }

        .file-size {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .file-progress {
            margin-top: 8px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .file-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4f46e5, #7c3aed);
            transition: width 0.3s;
        }

        .file-download {
            margin-top: 8px;
            padding: 8px 12px;
            background: rgba(99, 179, 237, 0.2);
            border: none;
            border-radius: 6px;
            color: #63b3ed;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .file-download:hover {
            background: rgba(99, 179, 237, 0.3);
        }

        /* Image preview */
        .image-preview {
            max-width: 300px;
            max-height: 200px;
            border-radius: 8px;
            margin-top: 8px;
            cursor: pointer;
        }

        /* Settings modal styles */
        .settings-modal {
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-section:last-child {
            border-bottom: none;
        }

        .settings-section h4 {
            color: #e2e8f0;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ice-server-item {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .ice-server-details {
            flex: 1;
        }

        .ice-server-details .server-url {
            color: #63b3ed;
            font-family: monospace;
            font-size: 0.85rem;
            margin-bottom: 4px;
        }

        .ice-server-details .server-credentials {
            color: #64748b;
            font-size: 0.75rem;
        }

        .ice-server-type {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .ice-server-type.stun {
            background: rgba(99, 179, 237, 0.2);
            color: #63b3ed;
        }

        .ice-server-type.turn {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .ice-server-type.turns {
            background: rgba(52, 211, 153, 0.2);
            color: #34d399;
        }

        .delete-ice-server {
            background: none;
            border: none;
            color: #ef4444;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .delete-ice-server:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .add-ice-server-form {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .add-ice-server-form .full-width {
            grid-column: 1 / -1;
        }

        .connection-status {
            padding: 12px;
            border-radius: 10px;
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .connection-status .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }

        .connection-status .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #64748b;
        }

        .connection-status .status-dot.connected {
            background: #34d399;
        }

        .connection-status .status-dot.connecting {
            background: #fbbf24;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .reset-btn {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .reset-btn:hover:not(:disabled) {
            background: rgba(239, 68, 68, 0.3);
        }

        /* Settings button in header */
        .settings-btn {
            position: absolute;
            top: 20px;
            right: 25px;
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.8);
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .settings-btn:hover {
            background: rgba(51, 65, 85, 0.8);
            color: #e2e8f0;
            transform: rotate(90deg);
        }

        /* Input area */
        .input-area {
            padding: 16px 20px;
            background: rgba(11, 18, 39, 0.95);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .input-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.8);
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: rgba(51, 65, 85, 0.8);
            color: #e2e8f0;
        }

        .action-btn.active {
            background: rgba(99, 179, 237, 0.2);
            color: #63b3ed;
            border-color: rgba(99, 179, 237, 0.3);
        }

        /* Small action buttons for participant management */
        .action-btn-small {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.6);
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
        }

        .action-btn-small:hover {
            background: rgba(51, 65, 85, 0.9);
            color: #e2e8f0;
            transform: scale(1.1);
        }

        .action-btn-small.warn {
            color: #fbbf24;
        }

        .action-btn-small.warn:hover {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border-color: rgba(251, 191, 36, 0.4);
        }

        .action-btn-small.danger {
            color: #f87171;
        }

        .action-btn-small.danger:hover {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border-color: rgba(248, 113, 113, 0.4);
        }

        .message-input-wrapper {
            flex: 1;
            position: relative;
        }

        .message-input {
            width: 100%;
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.8);
            color: white;
            font-size: 0.95rem;
            resize: none;
            min-height: 44px;
            max-height: 120px;
        }

        .message-input:focus {
            outline: none;
            border-color: rgba(99, 179, 237, 0.5);
        }

        .message-input:disabled {
            opacity: 0.5;
        }

        .send-btn {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            border: none;
            background: linear-gradient(45deg, #4f46e5, #7c3aed);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .send-btn:hover:not(:disabled) {
            transform: scale(1.05);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Typing indicator */
        .typing-indicator {
            padding: 8px 20px;
            color: #64748b;
            font-size: 0.8rem;
            display: none;
            flex-shrink: 0;
        }

        .typing-indicator.active {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .typing-dots {
            display: flex;
            gap: 3px;
        }

        .typing-dots span {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: #64748b;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .typing-dots span:nth-child(1) { animation-delay: 0s; }
        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-5px); }
        }

        /* File input hidden */
        #file-input {
            display: none;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(17, 24, 39, 0.95);
            color: white;
            padding: 14px 24px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            transition: transform 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        .toast.success { border-color: rgba(52, 211, 153, 0.5); }
        .toast.error { border-color: rgba(239, 68, 68, 0.5); }
        .toast.warning { border-color: rgba(251, 191, 36, 0.5); }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: rgba(15, 23, 42, 0.98);
            border-radius: 20px;
            padding: 24px;
            max-width: 450px;
            width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: scale(0.9);
            transition: transform 0.3s;
        }

        .modal-overlay.show .modal {
            transform: scale(1);
        }

        .modal h3 {
            color: #e2e8f0;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-actions .btn {
            flex: 1;
        }

        /* Connection status bar */
        .status-bar {
            padding: 8px 20px;
            background: rgba(11, 18, 39, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.8rem;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            flex-shrink: 0;
        }

        .status-bar.connecting {
            color: #fbbf24;
        }

        .status-bar.connected {
            color: #34d399;
        }

        .status-bar.error {
            color: #f87171;
        }

        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid currentColor;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: flex;
            }

            .mobile-close-btn {
                display: flex;
            }

            .main-layout {
                grid-template-columns: 1fr;
            }

            .sidebar {
                display: none;
            }

            .sidebar.mobile-show {
                display: flex;
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                width: 280px;
                z-index: 100;
                box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.9);
            }

            /* Sidebar needs relative positioning for absolute child (close button) */
            .sidebar {
                position: relative;
            }

            /* Ensure mobile-close-btn is positioned relative to sidebar */
            .sidebar .mobile-close-btn {
                position: absolute;
            }

            h1 {
                font-size: 1.6rem;
            }

            .badges {
                display: none;
            }

            /* Fix input area visibility on mobile */
            .input-area {
                position: sticky;
                bottom: 0;
                z-index: 10;
            }

            /* Ensure room detail container accounts for mobile viewport */
            .room-detail {
                height: 100vh;
                max-height: 100vh;
            }

            /* Ensure messages container has proper height on mobile */
            .messages-container {
                max-height: calc(100vh - 350px);
                flex: 1 1 auto;
            }

            /* Main area adjustments for mobile */
            .main-area {
                height: 100vh;
                max-height: 100vh;
            }

            /* Section containers for mobile */
            .section-container {
                height: 100vh;
                max-height: 100vh;
            }

            /* Typing indicator should not push input off screen */
            .typing-indicator {
                position: relative;
            }

            /* Tabs container scrolling on mobile */
            .tabs-container {
                padding: 15px 10px;
            }

            .tab {
                padding: 10px 15px;
                font-size: 0.85rem;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(99, 179, 237, 0.4);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(99, 179, 237, 0.6);
        }

        ::-webkit-scrollbar-corner {
            background: rgba(255, 255, 255, 0.05);
        }

        /* Firefox scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(99, 179, 237, 0.4) rgba(255, 255, 255, 0.05);
        }

        /* Room creation section */
        .room-options {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .room-option {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.5);
            color: #94a3b8;
            cursor: pointer;
            text-align: center;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .room-option:hover, .room-option.active {
            border-color: rgba(99, 179, 237, 0.5);
            color: #63b3ed;
            background: rgba(99, 179, 237, 0.1);
        }

        .encryption-info {
            background: rgba(52, 211, 153, 0.1);
            border: 1px solid rgba(52, 211, 153, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.75rem;
            color: #34d399;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .encryption-info svg {
            flex-shrink: 0;
            margin-top: 2px;
        }

        /* Tabs for Rooms and DM */
        .tabs-container {
            display: flex;
            gap: 10px;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(11, 18, 39, 0.8);
            flex-shrink: 0;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(99, 179, 237, 0.5) rgba(15, 23, 42, 0.5);
        }

        .tabs-container::-webkit-scrollbar {
            height: 6px;
        }

        .tabs-container::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 3px;
        }

        .tabs-container::-webkit-scrollbar-thumb {
            background: rgba(99, 179, 237, 0.5);
            border-radius: 3px;
        }

        .tab {
            flex: 0 0 auto;
            min-width: fit-content;
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.5);
            color: #94a3b8;
            cursor: pointer;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .tab:hover {
            border-color: rgba(99, 179, 237, 0.5);
            color: #63b3ed;
            background: rgba(99, 179, 237, 0.1);
        }

        .tab.active {
            border-color: rgba(99, 179, 237, 0.6);
            color: #fff;
            background: linear-gradient(45deg, #4f46e5, #7c3aed);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
        }

        /* Section containers */
        .section-container {
            display: none;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .section-container.active {
            display: flex;
        }

        /* Rooms section */
        .rooms-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .rooms-header h2 {
            color: #e2e8f0;
            font-size: 1.3rem;
            margin-bottom: 10px;
        }

        .rooms-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .rooms-actions-full {
            display: flex;
            gap: 10px;
        }

        .rooms-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .rooms-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            min-height: 0;
        }

        .room-card {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .room-card:hover {
            border-color: rgba(99, 179, 237, 0.4);
            background: rgba(30, 41, 59, 0.7);
            transform: translateY(-2px);
        }

        .room-card.active {
            border-color: rgba(99, 179, 237, 0.6);
            background: rgba(99, 179, 237, 0.1);
        }

        .room-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .room-card-name {
            color: #e2e8f0;
            font-size: 1rem;
            font-weight: 600;
        }

        .room-card-badge {
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: 600;
            background: rgba(52, 211, 153, 0.2);
            color: #34d399;
        }

        .room-card-info {
            color: #94a3b8;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .room-card-participants {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #64748b;
            font-size: 0.8rem;
        }

        /* Room multi-select mode */
        .room-card.selectable {
            position: relative;
            padding-left: 45px;
        }

        .room-card-checkbox {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 22px;
            height: 22px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(30, 41, 59, 0.5);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .room-card-checkbox:hover {
            border-color: rgba(99, 179, 237, 0.6);
        }

        .room-card.selected .room-card-checkbox {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .room-card.selected .room-card-checkbox svg {
            display: block;
        }

        .room-card-checkbox svg {
            display: none;
            color: white;
        }

        .room-card.selected {
            border-color: rgba(59, 130, 246, 0.6);
            background: rgba(59, 130, 246, 0.1);
        }

        .multi-select-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .multi-select-actions .btn {
            flex: 1;
        }

        .selection-count {
            color: #94a3b8;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            padding: 0 12px;
        }

        /* Room detail view */
        .room-detail {
            display: none;
            flex-direction: column;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .room-detail.active {
            display: flex;
        }

        .room-detail-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .room-detail-title h2 {
            color: #e2e8f0;
            font-size: 1.2rem;
            margin-bottom: 4px;
        }

        .room-detail-id {
            color: #94a3b8;
            font-size: 0.85rem;
        }

        .room-detail-actions {
            display: flex;
            gap: 8px;
        }

        /* Join requests section */
        .join-requests-section {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.2);
            border-radius: 0;
            padding: 16px 20px;
            margin: 0;
            flex-shrink: 0;
            border-left: none;
            border-right: none;
            border-top: none;
        }

        .join-requests-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .join-requests-title {
            color: #fbbf24;
            font-size: 0.95rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .join-request-item {
            background: rgba(11, 22, 47, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .join-request-info {
            color: #e2e8f0;
            font-size: 0.9rem;
        }

        .join-request-time {
            color: #64748b;
            font-size: 0.75rem;
        }

        .join-request-actions {
            display: flex;
            gap: 6px;
        }

        /* DM section */
        .dm-contacts {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            min-height: 0;
        }

        .dm-contact {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px;
            border-radius: 10px;
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dm-contact:hover {
            border-color: rgba(99, 179, 237, 0.4);
            background: rgba(30, 41, 59, 0.7);
        }

        .dm-contact.active {
            border-color: rgba(99, 179, 237, 0.6);
            background: rgba(99, 179, 237, 0.1);
        }

        .dm-contact-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #fff;
            font-weight: 600;
        }

        .dm-contact-info {
            flex: 1;
        }

        .dm-contact-name {
            color: #e2e8f0;
            font-size: 0.95rem;
            font-weight: 600;
        }

        .dm-contact-status {
            color: #94a3b8;
            font-size: 0.8rem;
        }

        .dm-contact-unread {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ef4444;
            color: #fff;
            font-size: 0.7rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dm-delete-btn {
            background: transparent;
            border: none;
            color: #64748b;
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            opacity: 0;
        }

        .dm-contact:hover .dm-delete-btn {
            opacity: 1;
        }

        .dm-delete-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        /* Friends section in sidebar */
        .friends-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .friends-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
            min-height: 0;
        }

        .friend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .friend-item:hover {
            background: rgba(30, 41, 59, 0.5);
        }

        .friend-item.offline {
            opacity: 0.6;
        }

        .friend-status {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #64748b;
        }

        .friend-status.online {
            background: #34d399;
            box-shadow: 0 0 8px rgba(52, 211, 153, 0.5);
        }

        .friend-name {
            color: #e2e8f0;
            font-size: 0.9rem;
            flex: 1;
        }

        /* Settings for DM restrictions */
        .dm-settings {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px;
            margin-top: 10px;
        }

        .dm-settings h4 {
            color: #94a3b8;
            font-size: 0.8rem;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .toggle-input {
            width: 44px;
            height: 24px;
            background: rgba(100, 116, 139, 0.3);
            border-radius: 12px;
            position: relative;
            transition: all 0.3s;
        }

        .toggle-input.active {
            background: #4f46e5;
        }

        .toggle-input::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: #fff;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: all 0.3s;
        }

        .toggle-input.active::after {
            left: 23px;
        }

        .toggle-label {
            color: #94a3b8;
            font-size: 0.85rem;
        }

        /* Add friend form */
        .add-friend-form {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .add-friend-form input {
            flex: 1;
        }

        /* Room creation modal */
        .room-creation-form {
            display: grid;
            gap: 12px;
        }

        .room-creation-field label {
            display: block;
            color: #94a3b8;
            font-size: 0.85rem;
            margin-bottom: 6px;
        }

        /* Access code display */
        .access-code-display {
            background: rgba(99, 179, 237, 0.1);
            border: 1px solid rgba(99, 179, 237, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }

        .access-code-label {
            color: #94a3b8;
            font-size: 0.8rem;
            margin-bottom: 6px;
        }

        .access-code-value {
            color: #63b3ed;
            font-family: monospace;
            font-size: 1rem;
            word-break: break-all;
        }

        /* Drag & Drop zone */
        .drag-drop-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
        }

        .drag-drop-overlay.active {
            display: flex;
        }

        .drag-drop-content {
            text-align: center;
            padding: 40px;
            border: 3px dashed #63b3ed;
            border-radius: 20px;
            background: rgba(99, 179, 237, 0.1);
        }

        .drag-drop-content svg {
            width: 80px;
            height: 80px;
            color: #63b3ed;
            margin-bottom: 20px;
        }

        .drag-drop-content h3 {
            color: #e2e8f0;
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .drag-drop-content p {
            color: #94a3b8;
        }

        /* Message search */
        .search-container {
            padding: 12px 20px;
            background: rgba(11, 18, 39, 0.8);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }

        .search-container.active {
            display: block;
        }

        .search-input-wrapper {
            position: relative;
            display: flex;
            gap: 8px;
        }

        .search-input {
            flex: 1;
            padding: 10px 40px 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(11, 22, 47, 0.7);
            color: white;
            font-size: 0.9rem;
        }

        .search-input:focus {
            outline: none;
            border-color: rgba(99, 179, 237, 0.6);
            box-shadow: 0 0 0 3px rgba(99, 179, 237, 0.15);
        }

        .search-clear-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #64748b;
            cursor: pointer;
            padding: 4px;
        }

        .search-results-info {
            font-size: 0.75rem;
            color: #64748b;
            margin-top: 6px;
        }

        /* Message with highlight */
        .message.highlight {
            background: rgba(251, 191, 36, 0.2);
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        /* Lazy loading placeholder */
        .image-placeholder {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 150px;
            color: #64748b;
        }

        .image-placeholder.loading::after {
            content: '';
            width: 24px;
            height: 24px;
            border: 3px solid rgba(99, 179, 237, 0.3);
            border-top-color: #63b3ed;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Burn after reading indicator */
        .burn-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 0.7rem;
            color: #ef4444;
            margin-top: 4px;
        }

        .burn-indicator svg {
            width: 12px;
            height: 12px;
        }

        /* E2E encryption indicator (enhanced) */
        .e2e-active-indicator {
            position: absolute;
            top: 75px;
            right: 25px;
            background: rgba(52, 211, 153, 0.2);
            border: 1px solid rgba(52, 211, 153, 0.4);
            color: #34d399;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            display: none;
            align-items: center;
            gap: 6px;
            z-index: 10;
        }

        .e2e-active-indicator.active {
            display: flex;
        }

        .e2e-active-indicator .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #34d399;
            animation: pulse 2s infinite;
        }

        /* Mobile: Minimize animations */
        @media (max-width: 768px) {
            .message {
                animation: none;
            }

            .btn-primary:hover:not(:disabled),
            .send-btn:hover:not(:disabled) {
                transform: none;
            }

            .settings-btn:hover {
                transform: none;
            }
        }

        /* Share button */
        .share-btn {
            margin-left: 8px;
            padding: 6px 10px;
            background: rgba(99, 179, 237, 0.2);
            border: 1px solid rgba(99, 179, 237, 0.3);
            color: #63b3ed;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .share-btn:hover {
            background: rgba(99, 179, 237, 0.3);
        }

        /* Swipe gesture indicator */
        .swipe-indicator {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            background: rgba(99, 179, 237, 0.2);
            width: 0;
            transition: width 0.2s;
            border-radius: 16px 0 0 16px;
        }

        .message.swiping .swipe-indicator {
            width: 60px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <button class="mobile-menu-btn" id="mobile-menu-btn" title="Menu" aria-label="Ouvrir le menu" aria-expanded="false">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </button>
            <button class="settings-btn" id="settings-btn" title="Paramètres de connexion" aria-label="Ouvrir les paramètres">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                </svg>
            </button>
            <h1>PeerText</h1>
            <p class="subtitle">Messagerie P2P chiffrée de bout en bout</p>
            <div class="badges" role="list" aria-label="Fonctionnalités de l'application">
                <span class="badge e2e" role="listitem">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                    </svg>
                    Chiffrement E2E AES-256
                </span>
                <span class="badge p2p" role="listitem">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                        <circle cx="12" cy="12" r="2"></circle>
                        <path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>
                    </svg>
                    WebRTC P2P
                </span>
                <span class="badge files" role="listitem">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                    </svg>
                    Transfert de fichiers
                </span>
                <span class="badge rooms" role="listitem">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                        <circle cx="9" cy="7" r="4"></circle>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                    </svg>
                    Salons multi-utilisateurs
                </span>
            </div>

            <!-- E2E Encryption Active Indicator -->
            <div class="e2e-active-indicator" id="e2e-indicator" role="status" aria-live="polite">
                <span class="status-dot"></span>
                <span>Chiffrement E2E actif</span>
            </div>
        </header>

        <!-- Mobile sidebar overlay -->
        <div class="sidebar-overlay" id="sidebar-overlay"></div>

        <div class="main-layout">
            <!-- Sidebar -->
            <div class="sidebar" id="sidebar">
                <button class="mobile-close-btn" id="mobile-close-btn" title="Fermer" aria-label="Fermer le menu">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>

                <!-- Friend requests section -->
                <div class="sidebar-section" id="friend-requests-section" style="display:none;">
                    <h3>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="8.5" cy="7" r="4"></circle>
                            <path d="M20 8v6M23 11h-6"></path>
                        </svg>
                        Demandes d'ami (<span id="friend-requests-count">0</span>)
                    </h3>
                    <div id="friend-requests-list"></div>
                    <div class="add-friend-form" style="margin-top:8px;">
                        <input type="text" id="accept-friend-id-input" class="input-field" placeholder="ID à valider (PT-XXXXXXXX)" style="margin-bottom:0;font-size:0.8rem;">
                        <button class="btn btn-success" id="accept-friend-btn" style="width:auto;padding:8px 12px;" title="Accepter">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Friends section -->
                <div class="sidebar-section friends-section">
                    <h3>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="8.5" cy="7" r="4"></circle>
                            <polyline points="17 11 19 13 23 9"></polyline>
                        </svg>
                        Amis
                    </h3>
                    <div class="friends-list" id="friends-list">
                        <div style="color:#64748b;font-size:0.85rem;text-align:center;padding:20px;">
                            Aucun ami
                        </div>
                    </div>
                </div>

                <!-- Room participants section -->
                <div class="sidebar-section" style="flex:1;display:flex;flex-direction:column;">
                    <h3>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                        </svg>
                        Participants du salon (<span id="participants-count">0</span>)
                    </h3>
                    <div class="peers-list" id="peers-list">
                        <div style="color:#64748b;font-size:0.85rem;text-align:center;padding:20px;">
                            Rejoignez un salon pour voir les participants
                        </div>
                    </div>
                </div>

            </div>

            <!-- Main area with tabs -->
            <div class="main-area">
                <!-- Tabs -->
                <div class="tabs-container" id="tabs-container">
                    <div class="tab active" id="rooms-tab" data-tab="rooms">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        Salons
                    </div>
                    <div class="tab" id="users-tab" data-tab="users">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        Utilisateurs connectés
                    </div>
                    <div class="tab" id="dm-tab" data-tab="dm">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                        Messages privés
                    </div>
                    <div class="tab" id="profile-tab" data-tab="profile">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                            <circle cx="12" cy="7" r="4"></circle>
                        </svg>
                        Mon Profil
                    </div>
                </div>

                <!-- Rooms Section -->
                <div class="section-container active" id="rooms-section">
                    <!-- Rooms list view -->
                    <div class="rooms-view" id="rooms-list-view">
                        <div class="rooms-header">
                            <h2>Mes salons privés</h2>
                            <div class="rooms-actions">
                                <button class="btn btn-secondary" id="refresh-rooms-btn" title="Actualiser la liste" style="width:auto;padding:8px 12px;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                                    </svg>
                                </button>
                                <input type="text" id="join-room-id-input" class="input-field" placeholder="ID du salon à rejoindre">
                                <button class="btn btn-primary" id="join-room-btn">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                                        <polyline points="15 3 21 3 21 9"></polyline>
                                        <line x1="10" y1="14" x2="21" y2="3"></line>
                                    </svg>
                                    Demander à rejoindre
                                </button>
                            </div>
                            <button class="btn btn-success rooms-actions-full" id="create-room-btn">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                                Créer un nouveau salon
                            </button>
                            <button class="btn btn-secondary rooms-actions-full" id="toggle-select-mode-btn" style="margin-top:8px;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="9 11 12 14 22 4"></polyline>
                                    <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
                                </svg>
                                Sélectionner
                            </button>
                        </div>
                        <!-- Multi-select actions bar -->
                        <div class="multi-select-actions" id="multi-select-actions" style="display:none;">
                            <span class="selection-count" id="selection-count">0 sélectionné(s)</span>
                            <button class="btn btn-danger" id="delete-selected-rooms-btn" style="width:auto;padding:8px 16px;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                                </svg>
                                Supprimer
                            </button>
                            <button class="btn btn-secondary" id="cancel-select-mode-btn" style="width:auto;padding:8px 16px;">
                                Annuler
                            </button>
                        </div>
                        <div class="rooms-list" id="private-rooms-list">
                            <div style="color:#64748b;font-size:0.9rem;text-align:center;padding:40px;">
                                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="margin-bottom:12px;">
                                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                                    <circle cx="9" cy="7" r="4"></circle>
                                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                                    <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                                </svg>
                                <p>Aucun salon. Créez-en un ou rejoignez un salon existant.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Room detail view -->
                    <div class="room-detail" id="room-detail">
                        <div class="room-detail-header">
                            <button class="btn btn-secondary" id="back-to-rooms-btn" style="width:auto;padding:8px 16px;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="19" y1="12" x2="5" y2="12"></line>
                                    <polyline points="12 19 5 12 12 5"></polyline>
                                </svg>
                                Retour
                            </button>
                            <div class="room-detail-title">
                                <h2 id="detail-room-name">Nom du salon</h2>
                                <span class="room-detail-id" id="detail-room-id">ID: XXXXXXXX</span>
                            </div>
                            <div class="room-detail-actions">
                                <button class="btn btn-secondary" id="copy-access-id-btn" style="width:auto;padding:8px 16px;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                    </svg>
                                    Copier l'ID
                                </button>
                                <button class="btn btn-danger" id="leave-room-btn" style="width:auto;padding:8px 16px;display:none;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                                        <polyline points="16 17 21 12 16 7"></polyline>
                                        <line x1="21" y1="12" x2="9" y2="12"></line>
                                    </svg>
                                    Quitter
                                </button>
                                <button class="btn btn-danger" id="delete-room-btn" style="width:auto;padding:8px 16px;display:none;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                                    </svg>
                                    Supprimer
                                </button>
                            </div>
                        </div>

                        <!-- Join requests section (for creators/admins) -->
                        <div class="join-requests-section" id="join-requests-section" style="display:none;padding:16px 20px;margin:0;border-radius:0;">
                            <div class="join-requests-header">
                                <span class="join-requests-title">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                                    </svg>
                                    Demandes de rejoindre (<span id="join-requests-count">0</span>)
                                </span>
                            </div>
                            <div id="join-requests-list"></div>
                            <div class="add-friend-form" style="margin-top:10px;display:flex;gap:8px;">
                                <input type="text" id="accept-join-id-input" class="input-field" placeholder="ID à accepter (PT-XXXXXXXX)" style="margin-bottom:0;font-size:0.8rem;flex:1;">
                                <button class="btn btn-success" id="accept-join-btn" style="width:auto;padding:8px 12px;" title="Accepter">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"></polyline>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Chat area in room -->
                        <div class="messages-container" id="messages-container">
                            <div class="message system">
                                Bienvenue dans le salon !
                            </div>
                        </div>

                        <div class="typing-indicator" id="typing-indicator">
                            <div class="typing-dots">
                                <span></span><span></span><span></span>
                            </div>
                            <span id="typing-names">Quelqu'un écrit...</span>
                        </div>

                        <div class="input-area">
                            <div class="input-row">
                                <div class="input-actions">
                                    <button class="action-btn" id="attach-btn" title="Envoyer un fichier">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                                        </svg>
                                    </button>
                                </div>
                                <div class="message-input-wrapper">
                                    <textarea id="message-input" class="message-input" placeholder="Écrivez votre message..." rows="1"></textarea>
                                </div>
                                <button class="send-btn" id="send-btn" title="Envoyer">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="22" y1="2" x2="11" y2="13"></line>
                                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="status-bar connecting" id="status-bar">
                            <div class="spinner"></div>
                            <span>Connexion au réseau P2P...</span>
                        </div>
                    </div>
                </div>

                <!-- Users Section -->
                <div class="section-container" id="users-section">
                    <div class="rooms-header">
                        <h2>Utilisateurs connectés (<span id="connected-users-count">0</span>)</h2>
                        <div style="font-size:0.8rem;color:#64748b;margin-top:4px;" id="discovery-status">
                            🔍 Découverte automatique...
                        </div>
                    </div>

                    <!-- Direct Connection -->
                    <div style="padding:20px;border-bottom:1px solid rgba(255, 255, 255, 0.1);">
                        <h3 style="color:#94a3b8;font-size:0.85rem;text-transform:uppercase;letter-spacing:1px;margin-bottom:12px;display:flex;align-items:center;gap:8px;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                                <polyline points="15 3 21 3 21 9"></polyline>
                                <line x1="10" y1="14" x2="21" y2="3"></line>
                            </svg>
                            Connexion directe
                        </h3>
                        <label for="peer-id-input" class="sr-only">ID du pair</label>
                        <input type="text" id="peer-id-input" class="input-field" placeholder="ID du pair (PT-XXXXXXXX)" style="text-transform:uppercase;" aria-label="ID du pair à connecter">
                        <button class="btn btn-primary" id="connect-peer-btn" aria-label="Se connecter au pair">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                                <polyline points="15 3 21 3 21 9"></polyline>
                                <line x1="10" y1="14" x2="21" y2="3"></line>
                            </svg>
                            Se connecter
                        </button>
                        <div class="encryption-info" style="margin-top:8px;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                            </svg>
                            <span>Échangez vos IDs puis connectez-vous. Chiffrement AES-256-GCM automatique.</span>
                        </div>
                    </div>

                    <div class="rooms-list" id="main-connected-users-list">
                        <div style="color:#64748b;font-size:0.85rem;text-align:center;padding:20px;">
                            🔍 Recherche d'utilisateurs en ligne...<br>
                            <small style="margin-top:8px;display:block;">Découverte automatique active</small>
                        </div>
                    </div>
                    <!-- Hidden element for backward compatibility -->
                    <div id="connected-users-list" style="display:none;"></div>
                </div>

                <!-- DM Section -->
                <div class="section-container" id="dm-section">
                    <div class="dm-contacts" id="dm-contacts-list">
                        <div style="color:#64748b;font-size:0.9rem;text-align:center;padding:40px;">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="margin-bottom:12px;">
                                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                            </svg>
                            <p>Aucune conversation. Ajoutez des amis depuis la barre latérale.</p>
                        </div>
                    </div>

                    <!-- DM conversation view -->
                    <div class="room-detail" id="dm-conversation" style="display:none;">
                        <div class="room-detail-header">
                            <button class="btn btn-secondary dm-back-btn" style="width:auto;padding:8px 16px;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="19" y1="12" x2="5" y2="12"></line>
                                    <polyline points="12 19 5 12 12 5"></polyline>
                                </svg>
                                Retour
                            </button>
                            <div class="room-detail-title">
                                <h2 id="dm-contact-name">Nom du contact</h2>
                                <span class="room-detail-id">Message privé</span>
                            </div>
                        </div>

                        <div class="messages-container" id="dm-messages">
                            <div class="message system">
                                Début de la conversation privée
                            </div>
                        </div>

                        <div class="typing-indicator dm-typing-indicator" style="display:none;">
                            <div class="typing-dots">
                                <span></span><span></span><span></span>
                            </div>
                        </div>

                        <div class="input-area">
                            <div class="input-row">
                                <div class="input-actions">
                                    <button class="action-btn dm-attach-btn" title="Envoyer un fichier">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                                        </svg>
                                    </button>
                                </div>
                                <div class="message-input-wrapper">
                                    <textarea id="dm-input" class="message-input" placeholder="Écrivez un message privé..." rows="1"></textarea>
                                </div>
                                <button class="send-btn dm-send-btn" title="Envoyer">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="22" y1="2" x2="11" y2="13"></line>
                                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Profile Section -->
                <div class="section-container" id="profile-section">
                    <div class="rooms-header">
                        <h2>Mon Profil</h2>
                    </div>

                    <!-- User Profile Info -->
                    <div style="padding:20px;border-bottom:1px solid rgba(255, 255, 255, 0.1);">
                        <h3 style="color:#94a3b8;font-size:0.85rem;text-transform:uppercase;letter-spacing:1px;margin-bottom:12px;display:flex;align-items:center;gap:8px;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                                <circle cx="12" cy="7" r="4"></circle>
                            </svg>
                            Informations
                        </h3>
                        <label for="my-name" class="sr-only">Votre pseudo</label>
                        <input type="text" id="my-name" class="input-field" placeholder="Votre pseudo" maxlength="20" aria-label="Votre pseudo">
                        <div class="my-info">
                            <div class="my-id" id="my-peer-id">Connexion...</div>
                            <button class="copy-btn" id="copy-id-btn" aria-label="Copier mon ID peer">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:inline;vertical-align:middle;margin-right:4px;">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                                Copier mon ID
                            </button>
                            <button class="share-btn" id="share-id-btn" aria-label="Partager mon ID" style="display:none;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="18" cy="5" r="3"></circle>
                                    <circle cx="6" cy="12" r="3"></circle>
                                    <circle cx="18" cy="19" r="3"></circle>
                                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                                </svg>
                                Partager
                            </button>
                        </div>
                    </div>

                    <!-- DM Settings -->
                    <div style="padding:20px;">
                        <h3 style="color:#94a3b8;font-size:0.85rem;text-transform:uppercase;letter-spacing:1px;margin-bottom:12px;display:flex;align-items:center;gap:8px;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="3"></circle>
                                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                            </svg>
                            Paramètres DM
                        </h3>
                        <div class="dm-settings">
                            <h4>Restrictions</h4>
                            <div class="toggle-switch" id="accept-dm-toggle">
                                <div class="toggle-input active"></div>
                                <span class="toggle-label">Accepter les messages de non-amis</span>
                            </div>
                        </div>
                    </div>

                    <!-- ID Generation Settings -->
                    <div style="padding:20px;border-top:1px solid rgba(255, 255, 255, 0.1);">
                        <h3 style="color:#94a3b8;font-size:0.85rem;text-transform:uppercase;letter-spacing:1px;margin-bottom:12px;display:flex;align-items:center;gap:8px;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                            </svg>
                            Identité
                        </h3>
                        <div class="dm-settings">
                            <h4>Génération de l'ID</h4>
                            <div class="toggle-switch" id="auto-generate-id-toggle">
                                <div class="toggle-input active"></div>
                                <span class="toggle-label">Générer un nouvel ID à chaque visite</span>
                            </div>
                            <p style="color:#64748b;font-size:0.75rem;margin-top:8px;line-height:1.4;">
                                Quand activé, votre ID change à chaque rafraîchissement de page pour plus de confidentialité. Désactivez pour garder un ID fixe.
                            </p>
                            <button class="btn btn-secondary" id="regenerate-id-btn" style="margin-top:12px;width:100%;display:none;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                                </svg>
                                Regénérer mon ID
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- File input -->
    <input type="file" id="file-input" multiple>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Room creation modal -->
    <div class="modal-overlay" id="room-creation-modal">
        <div class="modal">
            <h3>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                    <circle cx="9" cy="7" r="4"></circle>
                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                    <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                </svg>
                Créer un salon privé
            </h3>
            <div class="room-creation-form">
                <div class="room-creation-field">
                    <label>Nom du salon</label>
                    <input type="text" id="room-name-input" class="input-field" placeholder="Ex: Famille, Travail, Amis..." maxlength="50">
                </div>
                <button class="btn btn-primary" id="confirm-create-room-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                    Créer le salon
                </button>
                <button class="btn btn-secondary" id="cancel-create-room-btn">
                    Annuler
                </button>
            </div>
        </div>
    </div>

    <!-- Image modal -->
    <div class="modal-overlay" id="image-modal">
        <div class="modal" style="max-width:90%;max-height:90%;padding:10px;">
            <img id="modal-image" style="max-width:100%;max-height:80vh;border-radius:8px;">
        </div>
    </div>

    <!-- Settings modal -->
    <div class="modal-overlay" id="settings-modal">
        <div class="modal settings-modal">
            <h3>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                </svg>
                Configuration des serveurs ICE
            </h3>

            <!-- Connection status -->
            <div class="connection-status">
                <div class="status-indicator">
                    <span class="status-dot" id="connection-status-dot"></span>
                    <span id="connection-status-text">En attente de connexion...</span>
                </div>
            </div>

            <div class="settings-section">
                <h4>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="2" y1="12" x2="22" y2="12"></line>
                        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                    </svg>
                    Serveurs STUN/TURN configurés
                </h4>
                <div id="ice-servers-list">
                    <!-- ICE servers will be listed here -->
                </div>
            </div>

            <div class="settings-section">
                <h4>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="16"></line>
                        <line x1="8" y1="12" x2="16" y2="12"></line>
                    </svg>
                    Ajouter un serveur ICE
                </h4>
                <div class="add-ice-server-form">
                    <select id="ice-server-type" class="input-field">
                        <option value="stun">STUN</option>
                        <option value="turn">TURN (TCP)</option>
                        <option value="turns">TURN (TLS)</option>
                    </select>
                    <input type="text" id="ice-server-url" class="input-field" placeholder="URL (ex: stun:stun.example.com:3478)">
                    <input type="text" id="ice-server-username" class="input-field" placeholder="Nom d'utilisateur (TURN)">
                    <input type="password" id="ice-server-credential" class="input-field" placeholder="Mot de passe (TURN)">
                    <button class="btn btn-success" id="add-ice-server-btn">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                        Ajouter
                    </button>
                </div>
            </div>

            <div class="settings-section">
                <h4>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 12h-4l-3 9L9 3l-3 9H2"></path>
                    </svg>
                    Serveur de signalisation
                </h4>
                <div style="color:#94a3b8;font-size:0.8rem;margin-bottom:10px;">
                    Le serveur par défaut est utilisé. Vous pouvez configurer un serveur personnalisé ci-dessous.
                </div>
                <input type="text" id="signaling-host" class="input-field" placeholder="Host (ex: 0.peerjs.com)">
                <input type="number" id="signaling-port" class="input-field" placeholder="Port (ex: 443)" value="443">
                <input type="text" id="signaling-path" class="input-field" placeholder="Path (ex: /)" value="/">
                <button class="btn btn-secondary" id="save-signaling-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    Sauvegarder
                </button>
                <button class="btn btn-secondary reset-btn" id="reset-signaling-btn" style="margin-top:10px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                        <path d="M3 3v5h5"></path>
                    </svg>
                    Réinitialiser par défaut
                </button>
            </div>

            <div class="settings-section">
                <h4>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                        <line x1="9" y1="9" x2="9.01" y2="9"></line>
                        <line x1="15" y1="9" x2="15.01" y2="9"></line>
                    </svg>
                    Diagnostic et aide
                </h4>
                <div id="diagnostic-info" style="background:rgba(30, 41, 59, 0.5);border:1px solid rgba(255,255,255,0.1);border-radius:10px;padding:12px;font-size:0.85rem;color:#94a3b8;">
                    <div style="margin-bottom:8px;">
                        <strong>État actuel:</strong>
                        <div id="diagnostic-status">Chargement...</div>
                    </div>
                    <div style="margin-bottom:8px;">
                        <strong>Nombre de connexions P2P:</strong>
                        <span id="diagnostic-connections">0</span>
                    </div>
                    <div style="margin-bottom:8px;">
                        <strong>HTTPS:</strong>
                        <span id="diagnostic-https">-</span>
                    </div>
                    <div>
                        <strong>WebRTC supporté:</strong>
                        <span id="diagnostic-webrtc">-</span>
                    </div>
                </div>
                <div style="margin-top:15px;padding:10px;background:rgba(99, 179, 237, 0.1);border:1px solid rgba(99, 179, 237, 0.2);border-radius:8px;font-size:0.8rem;color:#63b3ed;">
                    <strong>💡 Conseils de dépannage:</strong>
                    <ul style="margin-left:20px;margin-top:8px;line-height:1.6;">
                        <li>Assurez-vous d'utiliser <strong>HTTPS</strong> (obligatoire pour WebRTC)</li>
                        <li>Ajoutez des serveurs TURN pour traverser les NAT/Firewalls</li>
                        <li>Vérifiez que votre pare-feu/antivirus ne bloque pas WebRTC</li>
                        <li>Si le pair est injoignable, il peut être hors ligne</li>
                        <li>Essayez de rafraîchir la page si la connexion au serveur échoue</li>
                    </ul>
                </div>
            </div>

            <div class="modal-actions">
                <button class="btn btn-secondary reset-btn" id="reset-ice-servers-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                        <path d="M3 3v5h5"></path>
                    </svg>
                    Réinitialiser
                </button>
                <button class="btn btn-secondary" id="close-settings-btn">Fermer</button>
            </div>
        </div>
    </div>

    <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    // Load custom ICE servers from localStorage or use default configuration
    const savedIceServers = localStorage.getItem('customIceServers');
    const defaultIceServers = [
        // STUN servers (public)
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:global.stun.twilio.com:3478' },
        // TURN servers (OpenRelay - Free for testing)
        { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
        { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
        { urls: 'turns:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' }
    ];

    // Load custom signaling server configuration
    const savedSignalingConfig = localStorage.getItem('signalingConfig');
    let signalingConfig = null;
    if (savedSignalingConfig) {
        try {
            signalingConfig = JSON.parse(savedSignalingConfig);
        } catch (e) {
            console.error('Error parsing signaling config:', e);
        }
    }

    const CONFIG = {
        peerOptions: {
            debug: 1,
            config: {
                iceServers: savedIceServers ? JSON.parse(savedIceServers) : defaultIceServers
            },
            ...(signalingConfig ? signalingConfig : {})
        },
        chunkSize: 16384, // 16KB chunks for file transfer
        maxFileSize: 100 * 1024 * 1024, // 100MB max
        typingTimeout: 2000
    };

    // ============================================
    // STATE
    // ============================================
    const state = {
        peer: null,
        myPeerId: null,
        myName: localStorage.getItem('peerName') || 'Anonyme',
        currentRoom: null,
        isRoomCreator: false,
        connections: new Map(), // peerId -> { conn, name, publicKey, sharedKey, role, username }
        pendingConnections: new Map(),
        myKeyPair: null,
        typingPeers: new Set(),
        typingTimer: null,
        isTyping: false,
        fileTransfers: new Map(), // transferId -> { chunks, metadata }
        // Moderation system
        roomAdmins: new Map(), // roomId -> Set<username>
        activeVotes: new Map(), // voteId -> { targetUsername, votes: Set<username>, expiresAt }
        bannedUsers: new Map(), // roomId -> Set<username>
        reportedUsers: new Map(), // roomId -> Map<username, { reporterUsername, reason, count }>
        myRole: 'participant', // 'creator', 'admin', 'participant'
        // Room system (private only)
        privateRooms: JSON.parse(localStorage.getItem('privateRooms') || '[]'), // Array of room objects
        currentTab: 'rooms', // 'rooms' or 'dm'
        // Friends & DM system
        friends: JSON.parse(localStorage.getItem('friends') || '[]'), // Array of usernames
        friendRequestsReceived: JSON.parse(localStorage.getItem('friendRequestsReceived') || '[]'), // Array<{username, peerId, timestamp}>
        friendRequestsSent: JSON.parse(localStorage.getItem('friendRequestsSent') || '[]'), // Array<{username, peerId, timestamp}>
        pendingJoinRequests: new Map(), // roomId -> Array<{username, peerId, timestamp}>
        allowDMFromNonFriends: localStorage.getItem('allowDMFromNonFriends') !== 'false',
        // Direct messages
        directMessages: new Map(), // username -> Array<{content, timestamp, fromMe}>
        activeDMConversation: null, // username of current DM conversation
        // Identity & discovery system
        usernameToPeerId: new Map(), // username -> current peerId
        peerIdToUsername: new Map(), // peerId -> username
        myPreviousPeerIds: JSON.parse(localStorage.getItem('myPreviousPeerIds') || '[]'), // Array of old peerIds
        // Connections by username for easy lookup
        connectionsByUsername: new Map(), // username -> { conn, name, publicKey, sharedKey, role, peerId }
        // Enhanced peer discovery (Ares/RetroShare style)
        discoveredPeers: new Map(), // peerId -> {name, lastSeen, lastHeartbeat, connectable, via}
        peerListVersion: 0, // Incremented when peer list changes
        lastPeerBroadcast: 0, // Timestamp of last broadcast
        // Bootstrap peers - known peers that help start the network
        bootstrapPeers: JSON.parse(localStorage.getItem('bootstrapPeers') || '[]'), // Array of peerIds
        lastBootstrapAttempt: 0,
        // Room multi-select mode
        roomSelectMode: false,
        selectedRooms: new Set(), // Set of room IDs
        // ID generation settings
        autoGenerateId: localStorage.getItem('autoGenerateId') !== 'false', // true by default
        savedPeerId: localStorage.getItem('savedPeerId') || null // Saved peer ID when auto-generate is off
    };

    // ============================================
    // DOM ELEMENTS
    // ============================================
    const elements = {
        myName: document.getElementById('my-name'),
        myPeerId: document.getElementById('my-peer-id'),
        copyIdBtn: document.getElementById('copy-id-btn'),
        peerIdInput: document.getElementById('peer-id-input'),
        connectPeerBtn: document.getElementById('connect-peer-btn'),
        peersList: document.getElementById('peers-list'),
        participantsCount: document.getElementById('participants-count'),
        headerParticipants: document.getElementById('header-participants'),
        roomName: document.getElementById('room-name'),
        currentRoomId: document.getElementById('current-room-id'),
        messagesContainer: document.getElementById('messages-container'),
        messageInput: document.getElementById('message-input'),
        sendBtn: document.getElementById('send-btn'),
        attachBtn: document.getElementById('attach-btn'),
        fileInput: document.getElementById('file-input'),
        typingIndicator: document.getElementById('typing-indicator'),
        typingNames: document.getElementById('typing-names'),
        statusBar: document.getElementById('status-bar'),
        toast: document.getElementById('toast'),
        imageModal: document.getElementById('image-modal'),
        modalImage: document.getElementById('modal-image'),
        settingsBtn: document.getElementById('settings-btn'),
        settingsModal: document.getElementById('settings-modal'),
        iceServersList: document.getElementById('ice-servers-list'),
        iceServerType: document.getElementById('ice-server-type'),
        iceServerUrl: document.getElementById('ice-server-url'),
        iceServerUsername: document.getElementById('ice-server-username'),
        iceServerCredential: document.getElementById('ice-server-credential'),
        addIceServerBtn: document.getElementById('add-ice-server-btn'),
        resetIceServersBtn: document.getElementById('reset-ice-servers-btn'),
        closeSettingsBtn: document.getElementById('close-settings-btn'),
        connectionStatusDot: document.getElementById('connection-status-dot'),
        connectionStatusText: document.getElementById('connection-status-text'),
        signalingHost: document.getElementById('signaling-host'),
        signalingPort: document.getElementById('signaling-port'),
        signalingPath: document.getElementById('signaling-path'),
        saveSignalingBtn: document.getElementById('save-signaling-btn'),
        resetSignalingBtn: document.getElementById('reset-signaling-btn'),
        diagnosticStatus: document.getElementById('diagnostic-status'),
        diagnosticConnections: document.getElementById('diagnostic-connections'),
        diagnosticHttps: document.getElementById('diagnostic-https'),
        diagnosticWebrtc: document.getElementById('diagnostic-webrtc'),
        mobileMenuBtn: document.getElementById('mobile-menu-btn'),
        mobileCloseBtn: document.getElementById('mobile-close-btn'),
        sidebar: document.getElementById('sidebar'),
        sidebarOverlay: document.getElementById('sidebar-overlay'),
        // New UI elements for rooms & DM
        tabsContainer: document.getElementById('tabs-container'),
        roomsTab: document.getElementById('rooms-tab'),
        usersTab: document.getElementById('users-tab'),
        dmTab: document.getElementById('dm-tab'),
        profileTab: document.getElementById('profile-tab'),
        roomsSection: document.getElementById('rooms-section'),
        usersSection: document.getElementById('users-section'),
        dmSection: document.getElementById('dm-section'),
        profileSection: document.getElementById('profile-section'),
        privateRoomsList: document.getElementById('private-rooms-list'),
        createRoomBtn: document.getElementById('create-room-btn'),
        joinRoomIdInput: document.getElementById('join-room-id-input'),
        joinRoomBtn: document.getElementById('join-room-btn'),
        roomNameInput: document.getElementById('room-name-input'),
        roomCreationModal: document.getElementById('room-creation-modal'),
        confirmCreateRoomBtn: document.getElementById('confirm-create-room-btn'),
        cancelCreateRoomBtn: document.getElementById('cancel-create-room-btn'),
        backToRoomsBtn: document.getElementById('back-to-rooms-btn'),
        roomDetail: document.getElementById('room-detail'),
        detailRoomName: document.getElementById('detail-room-name'),
        detailRoomId: document.getElementById('detail-room-id'),
        copyAccessIdBtn: document.getElementById('copy-access-id-btn'),
        leaveRoomBtn: document.getElementById('leave-room-btn'),
        deleteRoomBtn: document.getElementById('delete-room-btn'),
        joinRequestsSection: document.getElementById('join-requests-section'),
        joinRequestsList: document.getElementById('join-requests-list'),
        joinRequestsCount: document.getElementById('join-requests-count'),
        acceptJoinIdInput: document.getElementById('accept-join-id-input'),
        acceptJoinBtn: document.getElementById('accept-join-btn'),
        // DM elements
        dmContactsList: document.getElementById('dm-contacts-list'),
        dmConversation: document.getElementById('dm-conversation'),
        dmMessages: document.getElementById('dm-messages'),
        dmInput: document.getElementById('dm-input'),
        dmSendBtn: document.querySelector('.dm-send-btn'),
        dmAttachBtn: document.querySelector('.dm-attach-btn'),
        dmBackBtn: document.querySelectorAll('.dm-back-btn'),
        dmContactName: document.getElementById('dm-contact-name'),
        // Connected users elements
        connectedUsersList: document.getElementById('connected-users-list'),
        mainConnectedUsersList: document.getElementById('main-connected-users-list'),
        connectedUsersCount: document.getElementById('connected-users-count'),
        // Friend requests elements
        friendRequestsSection: document.getElementById('friend-requests-section'),
        friendRequestsList: document.getElementById('friend-requests-list'),
        friendRequestsCount: document.getElementById('friend-requests-count'),
        acceptFriendIdInput: document.getElementById('accept-friend-id-input'),
        acceptFriendBtn: document.getElementById('accept-friend-btn'),
        // Friends elements
        friendsList: document.getElementById('friends-list'),
        acceptDMToggle: document.getElementById('accept-dm-toggle'),
        // Multi-select room elements
        toggleSelectModeBtn: document.getElementById('toggle-select-mode-btn'),
        multiSelectActions: document.getElementById('multi-select-actions'),
        deleteSelectedRoomsBtn: document.getElementById('delete-selected-rooms-btn'),
        cancelSelectModeBtn: document.getElementById('cancel-select-mode-btn'),
        selectionCount: document.getElementById('selection-count'),
        // ID generation elements
        autoGenerateIdToggle: document.getElementById('auto-generate-id-toggle'),
        regenerateIdBtn: document.getElementById('regenerate-id-btn')
    };

    // ============================================
    // CRYPTO - E2E ENCRYPTION
    // ============================================
    const Crypto = {
        async generateKeyPair() {
            return await window.crypto.subtle.generateKey(
                { name: 'ECDH', namedCurve: 'P-256' },
                true,
                ['deriveKey', 'deriveBits']
            );
        },

        async exportPublicKey(publicKey) {
            const exported = await window.crypto.subtle.exportKey('raw', publicKey);
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        },

        async importPublicKey(base64Key) {
            const binary = atob(base64Key);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return await window.crypto.subtle.importKey(
                'raw',
                bytes,
                { name: 'ECDH', namedCurve: 'P-256' },
                true,
                []
            );
        },

        async deriveSharedKey(privateKey, publicKey) {
            return await window.crypto.subtle.deriveKey(
                { name: 'ECDH', public: publicKey },
                privateKey,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        },

        async encrypt(sharedKey, data) {
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encoded = new TextEncoder().encode(JSON.stringify(data));
            const encrypted = await window.crypto.subtle.encrypt(
                { name: 'AES-GCM', iv },
                sharedKey,
                encoded
            );
            return {
                iv: btoa(String.fromCharCode(...iv)),
                data: btoa(String.fromCharCode(...new Uint8Array(encrypted)))
            };
        },

        async decrypt(sharedKey, encryptedData) {
            const iv = new Uint8Array(atob(encryptedData.iv).split('').map(c => c.charCodeAt(0)));
            const data = new Uint8Array(atob(encryptedData.data).split('').map(c => c.charCodeAt(0)));
            const decrypted = await window.crypto.subtle.decrypt(
                { name: 'AES-GCM', iv },
                sharedKey,
                data
            );
            return JSON.parse(new TextDecoder().decode(decrypted));
        },

        async encryptFile(sharedKey, arrayBuffer) {
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await window.crypto.subtle.encrypt(
                { name: 'AES-GCM', iv },
                sharedKey,
                arrayBuffer
            );
            return { iv, encrypted: new Uint8Array(encrypted) };
        },

        async decryptFile(sharedKey, iv, encryptedData) {
            return await window.crypto.subtle.decrypt(
                { name: 'AES-GCM', iv },
                sharedKey,
                encryptedData
            );
        }
    };

    // ============================================
    // INITIALIZATION
    // ============================================
    async function init() {
        elements.myName.value = state.myName;

        // Load saved data
        loadDirectMessages();

        // Migrate old data from peerId-based to username-based
        migrateOldData();

        // Generate encryption keys
        state.myKeyPair = await Crypto.generateKeyPair();

        // Event listeners
        elements.myName.addEventListener('input', handleNameChange);
        elements.copyIdBtn.addEventListener('click', copyPeerId);
        elements.connectPeerBtn.addEventListener('click', handleConnectPeer);
        elements.peerIdInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') handleConnectPeer();
        });
        elements.sendBtn.addEventListener('click', sendMessage);
        elements.messageInput.addEventListener('keydown', handleMessageKeydown);
        elements.messageInput.addEventListener('input', handleTyping);
        elements.attachBtn.addEventListener('click', () => elements.fileInput.click());
        elements.fileInput.addEventListener('change', handleFileSelect);
        elements.imageModal.addEventListener('click', () => elements.imageModal.classList.remove('show'));

        // Settings modal event listeners
        elements.settingsBtn.addEventListener('click', () => openSettingsModal());
        elements.closeSettingsBtn.addEventListener('click', () => closeSettingsModal());
        elements.settingsModal.addEventListener('click', (e) => {
            if (e.target === elements.settingsModal) closeSettingsModal();
        });
        elements.addIceServerBtn.addEventListener('click', addIceServer);
        elements.resetIceServersBtn.addEventListener('click', resetIceServers);
        elements.saveSignalingBtn.addEventListener('click', saveSignalingConfig);
        elements.resetSignalingBtn.addEventListener('click', resetSignalingConfig);

        // Mobile menu event listeners
        elements.mobileMenuBtn.addEventListener('click', toggleMobileSidebar);
        elements.mobileCloseBtn.addEventListener('click', toggleMobileSidebar);
        elements.sidebarOverlay.addEventListener('click', toggleMobileSidebar);

        // Refresh rooms button
        const refreshRoomsBtn = document.getElementById('refresh-rooms-btn');
        if (refreshRoomsBtn) {
            refreshRoomsBtn.addEventListener('click', refreshRoomsList);
        }

        // Tab switching
        elements.roomsTab.addEventListener('click', () => switchTab('rooms'));
        elements.usersTab.addEventListener('click', () => switchTab('users'));
        elements.dmTab.addEventListener('click', () => switchTab('dm'));
        elements.profileTab.addEventListener('click', () => switchTab('profile'));

        // Room creation and management
        elements.createRoomBtn.addEventListener('click', openRoomCreationModal);
        elements.confirmCreateRoomBtn.addEventListener('click', createPrivateRoom);
        elements.cancelCreateRoomBtn.addEventListener('click', closeRoomCreationModal);
        elements.roomCreationModal.addEventListener('click', (e) => {
            if (e.target === elements.roomCreationModal) closeRoomCreationModal();
        });

        // Join room
        elements.joinRoomBtn.addEventListener('click', requestToJoinRoom);

        // Room multi-select mode
        elements.toggleSelectModeBtn.addEventListener('click', toggleRoomSelectMode);
        elements.cancelSelectModeBtn.addEventListener('click', cancelRoomSelectMode);
        elements.deleteSelectedRoomsBtn.addEventListener('click', deleteSelectedRooms);

        // Room detail navigation
        elements.backToRoomsBtn.addEventListener('click', backToRoomsList);

        // Copy room access ID
        elements.copyAccessIdBtn.addEventListener('click', copyRoomAccessId);

        // Leave/Delete room
        elements.leaveRoomBtn.addEventListener('click', leaveRoom);
        elements.deleteRoomBtn.addEventListener('click', deleteRoom);

        // Join request acceptance (for room admins)
        elements.acceptJoinBtn?.addEventListener('click', acceptJoinByPeerId);
        elements.acceptJoinIdInput?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') acceptJoinByPeerId();
        });

        // Friend request acceptance
        elements.acceptFriendBtn.addEventListener('click', acceptFriendByPeerId);
        elements.acceptFriendIdInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') acceptFriendByPeerId();
        });

        // DM settings toggle
        elements.acceptDMToggle.addEventListener('click', toggleDmSettings);

        // ID generation settings
        elements.autoGenerateIdToggle.addEventListener('click', toggleAutoGenerateId);
        elements.regenerateIdBtn.addEventListener('click', regenerateUserId);

        // DM message sending
        elements.dmSendBtn.addEventListener('click', sendDirectMessage);
        elements.dmInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendDirectMessage();
            }
        });

        // DM file sending
        elements.dmAttachBtn.addEventListener('click', () => {
            if (!state.activeDMConversation) {
                showToast('Veuillez d\'abord sélectionner une conversation', 'warning');
                return;
            }
            console.log('DM file attach clicked, activeDMConversation:', state.activeDMConversation);
            elements.fileInput.dataset.context = 'dm';
            elements.fileInput.dataset.recipient = state.activeDMConversation;
            elements.fileInput.click();
        });

        // DM typing indicator
        let dmTypingTimer;
        elements.dmInput.addEventListener('input', () => {
            if (state.activeDMConversation) {
                // Send typing indicator
                const connection = state.connectionsByUsername.get(state.activeDMConversation);
                if (connection) {
                    const encrypted = encryptMessage('typing:true', connection.sharedKey);
                    connection.conn.send(JSON.stringify({
                        type: 'dm-typing',
                        content: encrypted,
                        recipient: state.activeDMConversation
                    }));
                }

                // Clear timer
                clearTimeout(dmTypingTimer);
                dmTypingTimer = setTimeout(() => {
                    const connection = state.connectionsByUsername.get(state.activeDMConversation);
                    if (connection) {
                        const encrypted = encryptMessage('typing:false', connection.sharedKey);
                        connection.conn.send(JSON.stringify({
                            type: 'dm-typing',
                            content: encrypted,
                            recipient: state.activeDMConversation
                        }));
                    }
                }, 1000);
            }
        });

        // DM back buttons
        elements.dmBackBtn.forEach(btn => {
            btn.addEventListener('click', backToDmList);
        });

        // Initialize UI
        updateConnectedUsersList();
        updateFriendRequestsList();
        updateFriendsList();
        updatePrivateRoomsList();
        updateDmContactsList();
        initAutoGenerateIdUI();

        // Initialize PeerJS
        initializePeer();

        // Save current peerId mapping for this username
        savePeerIdMapping();

        // Start ping/pong interval for connection health
        startConnectionHealthCheck();
    }

    function savePeerIdMapping() {
        // Save mapping: username -> current peerId
        const mapping = JSON.parse(localStorage.getItem('usernamePeerIdMapping') || '{}');
        mapping[state.myName] = state.myPeerId;
        localStorage.setItem('usernamePeerIdMapping', JSON.stringify(mapping));
    }

    function getPeerIdForUsername(username) {
        const mapping = JSON.parse(localStorage.getItem('usernamePeerIdMapping') || '{}');
        return mapping[username];
    }

    // Connection health check
    function startConnectionHealthCheck() {
        // Send ping every 30 seconds
        setInterval(() => {
            state.connections.forEach(({ conn }) => {
                if (conn && conn.open) {
                    conn.send({
                        type: 'ping',
                        timestamp: Date.now()
                    });
                }
            });

            // Check for stale connections (no response in 60 seconds)
            const now = Date.now();
            state.connections.forEach((info, peerId) => {
                if (info.lastSeen && now - info.lastSeen > 60000) {
                    console.log(`Peer ${peerId} appears disconnected`);
                    appendSystemMessage(`${info.name || 'Un utilisateur'} semble déconnecté`);
                }
            });
        }, 30000);
    }

    // Handle direct peer connection
    function handleConnectPeer() {
        const input = elements.peerIdInput.value.trim();

        if (!input) {
            showToast('Entrez l\'ID du pair ou le nom d\'utilisateur', 'error');
            return;
        }

        // Check if input looks like a peerId (PT-XXXXXXXX format)
        const isPeerIdFormat = /^PT-[A-Z0-9]{8}$/.test(input.toUpperCase());
        let targetPeerId = input.toUpperCase();
        let targetUsername = input;

        if (!isPeerIdFormat) {
            // Treat as username - try to find current peerId
            const foundPeerId = getPeerIdForUsername(input);
            if (foundPeerId) {
                targetPeerId = foundPeerId;
                targetUsername = input;
                showToast(`Résolution du nom d\'utilisateur "${input}" vers ${foundPeerId}`, 'info');
            } else {
                showToast(`Nom d\'utilisateur "${input}" non trouvé. Assurez-vous que l\'utilisateur est connecté.`, 'warning');
                return;
            }
        }

        if (targetPeerId === state.myPeerId) {
            showToast('Vous ne pouvez pas vous connecter à vous-même', 'error');
            return;
        }

        if (state.connections.has(targetPeerId)) {
            showToast('Déjà connecté à ce pair', 'warning');
            return;
        }

        appendSystemMessage(`Connexion à ${targetUsername} (${targetPeerId})...`);
        connectToPeer(targetPeerId);
        elements.peerIdInput.value = '';
    }

    // ============================================
    // ICE SERVERS CONFIGURATION
    // ============================================
    function openSettingsModal() {
        renderIceServersList();
        loadSignalingConfig();
        updateConnectionStatus();
        updateDiagnostics();
        elements.settingsModal.classList.add('show');
    }

    function updateDiagnostics() {
        // Connection status
        if (state.peer && state.peer.id) {
            elements.diagnosticStatus.textContent = '✅ Connecté';
            elements.diagnosticStatus.style.color = '#34d399';
        } else {
            elements.diagnosticStatus.textContent = '❌ Non connecté';
            elements.diagnosticStatus.style.color = '#ef4444';
        }

        // P2P connections
        elements.diagnosticConnections.textContent = state.connections.size;
        if (state.connections.size > 0) {
            elements.diagnosticConnections.style.color = '#34d399';
        } else {
            elements.diagnosticConnections.style.color = '#fbbf24';
        }

        // HTTPS check
        const isHttps = window.location.protocol === 'https:';
        elements.diagnosticHttps.textContent = isHttps ? '✅ Oui' : '❌ Non (Requis pour WebRTC)';
        elements.diagnosticHttps.style.color = isHttps ? '#34d399' : '#ef4444';

        // WebRTC support
        const hasWebRTC = !!(window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection);
        elements.diagnosticWebrtc.textContent = hasWebRTC ? '✅ Oui' : '❌ Non';
        elements.diagnosticWebrtc.style.color = hasWebRTC ? '#34d399' : '#ef4444';
    }

    function closeSettingsModal() {
        elements.settingsModal.classList.remove('show');
    }

    function renderIceServersList() {
        const iceServers = CONFIG.peerOptions.config.iceServers;

        if (iceServers.length === 0) {
            elements.iceServersList.innerHTML = `
                <div style="color:#64748b;font-size:0.85rem;text-align:center;padding:20px;">
                    Aucun serveur ICE configuré
                </div>
            `;
            return;
        }

        elements.iceServersList.innerHTML = iceServers.map((server, index) => {
            const url = server.urls;
            const type = getIceServerType(url);
            const hasCredentials = server.username || server.credential;

            return `
                <div class="ice-server-item">
                    <span class="ice-server-type ${type}">${type}</span>
                    <div class="ice-server-details">
                        <div class="server-url">${escapeHtml(url)}</div>
                        ${hasCredentials ? `
                            <div class="server-credentials">
                                ${server.username ? `User: ${escapeHtml(server.username)}` : ''}
                                ${server.username && server.credential ? ' | ' : ''}
                                ${server.credential ? '••••••••' : ''}
                            </div>
                        ` : ''}
                    </div>
                    <button class="delete-ice-server" onclick="removeIceServer(${index})" title="Supprimer">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
            `;
        }).join('');
    }

    function getIceServerType(url) {
        if (url.startsWith('stun:')) return 'stun';
        if (url.startsWith('turns:')) return 'turns';
        if (url.startsWith('turn:')) return 'turn';
        return 'unknown';
    }

    function addIceServer() {
        const type = elements.iceServerType.value;
        const url = elements.iceServerUrl.value.trim();

        if (!url) {
            showToast('Veuillez entrer l\'URL du serveur', 'error');
            return;
        }

        const newServer = { urls: url };

        // Add credentials for TURN servers
        if (type !== 'stun') {
            const username = elements.iceServerUsername.value.trim();
            const credential = elements.iceServerCredential.value;

            if (username) newServer.username = username;
            if (credential) newServer.credential = credential;
        }

        // Add to configuration
        CONFIG.peerOptions.config.iceServers.push(newServer);

        // Save to localStorage
        localStorage.setItem('customIceServers', JSON.stringify(CONFIG.peerOptions.config.iceServers));

        // Clear form
        elements.iceServerUrl.value = '';
        elements.iceServerUsername.value = '';
        elements.iceServerCredential.value = '';

        // Re-render
        renderIceServersList();
        showToast('Serveur ICE ajouté', 'success');
    }

    window.removeIceServer = function(index) {
        CONFIG.peerOptions.config.iceServers.splice(index, 1);
        localStorage.setItem('customIceServers', JSON.stringify(CONFIG.peerOptions.config.iceServers));
        renderIceServersList();
        showToast('Serveur ICE supprimé', 'success');
    };

    function resetIceServers() {
        if (confirm('Voulez-vous vraiment réinitialiser aux serveurs par défaut ?')) {
            localStorage.removeItem('customIceServers');
            CONFIG.peerOptions.config.iceServers = [...defaultIceServers];
            renderIceServersList();
            showToast('Configuration réinitialisée', 'success');

            // Note: For the new servers to take effect, the user needs to refresh the page
            showToast('Actualisez la page pour appliquer les changements', 'warning');
        }
    }

    function updateConnectionStatus() {
        if (state.peer && state.peer.id) {
            elements.connectionStatusDot.classList.add('connected');
            elements.connectionStatusText.textContent = 'Connecté au réseau P2P';
        } else {
            elements.connectionStatusDot.classList.remove('connected');
            elements.connectionStatusText.textContent = 'En attente de connexion...';
        }
    }

    function loadSignalingConfig() {
        const savedConfig = localStorage.getItem('signalingConfig');
        if (savedConfig) {
            try {
                const config = JSON.parse(savedConfig);
                elements.signalingHost.value = config.host || '';
                elements.signalingPort.value = config.port || '443';
                elements.signalingPath.value = config.path || '/';
            } catch (e) {
                console.error('Error loading signaling config:', e);
            }
        }
    }

    function saveSignalingConfig() {
        const host = elements.signalingHost.value.trim();
        const port = parseInt(elements.signalingPort.value) || 443;
        const path = elements.signalingPath.value.trim() || '/';

        if (!host) {
            showToast('Veuillez entrer l\'hôte du serveur', 'error');
            return;
        }

        const config = { host, port, path };
        localStorage.setItem('signalingConfig', JSON.stringify(config));
        showToast('Configuration du serveur sauvegardée', 'success');

        // Inform user that reload is needed
        showToast('Actualisez la page pour appliquer les changements', 'warning');
    }

    function resetSignalingConfig() {
        if (confirm('Voulez-vous vraiment réinitialiser au serveur par défaut ?')) {
            localStorage.removeItem('signalingConfig');
            elements.signalingHost.value = '';
            elements.signalingPort.value = '443';
            elements.signalingPath.value = '/';
            showToast('Configuration réinitialisée', 'success');
            showToast('Actualisez la page pour appliquer les changements', 'warning');
        }
    }

    function initializePeer() {
        let peerId;

        if (state.autoGenerateId) {
            // Generate new ID each time (default behavior)
            peerId = 'PT-' + generateId(8);
        } else {
            // Use saved ID or generate one if not exists
            if (state.savedPeerId) {
                peerId = state.savedPeerId;
            } else {
                peerId = 'PT-' + generateId(8);
                state.savedPeerId = peerId;
                localStorage.setItem('savedPeerId', peerId);
            }
        }

        try {
            state.peer = new Peer(peerId, CONFIG.peerOptions);

            state.peer.on('open', (id) => {
                state.myPeerId = id;
                elements.myPeerId.textContent = id;
                updateStatusBar('connected', 'Connecté au réseau P2P');
                updateConnectionStatus();
                updateDiagnostics();
                appendSystemMessage('✅ Connecté au serveur de signalisation');

                // Initialize Firebase for automatic discovery
                initFirebase();

                // Check if we have bootstrap peers
                if (state.bootstrapPeers.length > 0) {
                    appendSystemMessage(`📡 Tentative de reconnexion à ${state.bootstrapPeers.length} peer(s) connu(s)...`);
                } else if (!FIREBASE_ENABLED) {
                    appendSystemMessage('ℹ️ Première session détectée');
                    appendSystemMessage('💡 Connectez-vous manuellement à un utilisateur pour rejoindre le réseau');
                    appendSystemMessage('📝 Après la première connexion, la découverte automatique sera activée');
                }

                enableChat();

                // Start automatic peer discovery (Ares/RetroShare style)
                discoverPeers();
                setInterval(discoverPeers, 10000); // Discover from server every 10s

                // Try bootstrap peers immediately (helps with cold start)
                setTimeout(tryBootstrapPeers, 2000);
                setInterval(tryBootstrapPeers, 30000); // Retry bootstrap every 30s

                // Start heartbeat system
                setInterval(sendHeartbeat, 5000); // Send heartbeat every 5s

                // Start peer list broadcasting (gossip protocol)
                setInterval(broadcastPeerList, 15000); // Broadcast every 15s

                // Announce presence every 10s
                setInterval(announcePresenceToDiscoveryRoom, 10000);
            });

            state.peer.on('connection', handleIncomingConnection);
            state.peer.on('error', handlePeerError);
            state.peer.on('disconnected', () => {
                console.log('Peer disconnected from signaling server');
                updateStatusBar('warning', 'Connexion serveur perdue. Reconnexion...');
                appendSystemMessage('⚠️ Connexion au serveur de signalisation perdue. Tentative de reconnexion...');
                // P2P connections remain active even if signaling server is lost
                // Reconnect to signaling server after delay
                setTimeout(() => {
                    try {
                        state.peer.reconnect();
                        console.log('Reconnecting to signaling server...');
                    } catch (e) {
                        console.error('Reconnect error:', e);
                        appendSystemMessage('❌ Impossible de se reconnecter au serveur. Essayez de rafraîchir la page.');
                    }
                }, 2000);
            });

        } catch (error) {
            console.error('Init error:', error);
            updateStatusBar('error', 'Erreur d\'initialisation');
            appendSystemMessage('❌ Erreur d\'initialisation: ' + error.message);
            appendSystemMessage('💡 Astuce: Vérifiez votre connexion internet et les paramètres du serveur de signalisation ⚙️');
        }
    }

    // ============================================
    // FIREBASE CONFIGURATION (Auto Peer Discovery)
    // ============================================

    // Firebase configuration - Me2U Project
    const FIREBASE_ENABLED = true; // ✅ ACTIVÉ

    const firebaseConfig = {
        apiKey: "AIzaSyCSxvad5xHRT6TvQ4Smt6wgBz9AEHGEj2Q",
        authDomain: "me2u-7115d.firebaseapp.com",
        databaseURL: "https://me2u-7115d-default-rtdb.firebaseio.com",
        projectId: "me2u-7115d",
        storageBucket: "me2u-7115d.firebasestorage.app",
        messagingSenderId: "148951753804",
        appId: "1:148951753804:web:fb8caced544e36a53880e9",
        measurementId: "G-JZ6YDM5JZS"
    };

    let firebaseDb = null;
    let firebaseMyRef = null;

    // Initialiser Firebase si activé
    function initFirebase() {
        if (!FIREBASE_ENABLED) {
            console.log('ℹ️ Firebase désactivé. Voir FIREBASE_SETUP.md pour activer la découverte automatique');
            return;
        }

        if (typeof firebase === 'undefined') {
            console.error('❌ Firebase SDK non chargé');
            return;
        }

        try {
            // Initialiser Firebase
            if (!firebase.apps.length) {
                firebase.initializeApp(firebaseConfig);
            }
            firebaseDb = firebase.database();

            console.log('✅ Firebase initialisé - Découverte automatique activée!');
            appendSystemMessage('🔥 Firebase: Découverte automatique des peers activée');

            // IMPORTANT: Écouter AVANT de s'enregistrer pour capturer les peers existants
            listenForFirebasePeers();

            // Ensuite s'enregistrer
            registerInFirebase();

        } catch (error) {
            console.error('❌ Erreur initialisation Firebase:', error);
            appendSystemMessage('⚠️ Erreur Firebase: ' + error.message);
        }
    }

    // S'enregistrer dans Firebase
    function registerInFirebase() {
        if (!firebaseDb || !state.myPeerId) return;

        firebaseMyRef = firebaseDb.ref(`peers/${state.myPeerId}`);

        // Données du peer
        const peerData = {
            name: state.myName,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            online: true,
            peerId: state.myPeerId
        };

        // S'enregistrer
        firebaseMyRef.set(peerData)
            .then(() => {
                console.log('🔥 Firebase: Enregistré avec succès');
            })
            .catch(error => {
                console.error('❌ Firebase register error:', error);
            });

        // Auto-cleanup à la déconnexion
        firebaseMyRef.onDisconnect().remove();

        // Heartbeat toutes les 30s
        setInterval(() => {
            if (firebaseMyRef) {
                firebaseMyRef.update({
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                    name: state.myName
                });
            }
        }, 30000);
    }

    // Écouter l'ajout de nouveaux peers
    async function listenForFirebasePeers() {
        if (!firebaseDb) {
            console.error('❌ Firebase DB not initialized');
            return;
        }

        console.log('👂 Firebase: Starting to listen for peers...');
        console.log('🆔 My Peer ID:', state.myPeerId);

        const peersRef = firebaseDb.ref('peers');

        // Charger tous les peers existants
        console.log('📖 Loading existing peers from Firebase...');
        try {
            const snapshot = await peersRef.once('value');
            const existingPeers = snapshot.val() || {};
            const peerIds = Object.keys(existingPeers);

            console.log(`📊 Found ${peerIds.length} peer(s) in Firebase:`, peerIds);

            // Traiter chaque peer existant
            for (const peerId of peerIds) {
                const data = existingPeers[peerId];

                if (peerId === state.myPeerId) {
                    console.log(`⏭️  Skipping self in initial load (${peerId})`);
                    continue;
                }
                if (!peerId.startsWith('PT-')) {
                    console.log(`⏭️  Skipping invalid peer ID in initial load (${peerId})`);
                    continue;
                }

                console.log(`🔥 Firebase (initial): Peer discovered: ${data.name} (${peerId})`);
                handleFirebasePeerDiscovered(peerId, data);
            }

            console.log('✅ Initial peer load complete');
        } catch (error) {
            console.error('❌ Error loading initial peers:', error);
        }

        // Ensuite, écouter les nouveaux peers qui s'ajoutent
        console.log('👂 Now listening for new peers...');
        peersRef.on('child_added', (snapshot) => {
            const peerId = snapshot.key;
            const data = snapshot.val();

            console.log(`📥 Firebase child_added event:`, { peerId, data });

            // Si c'est un peer qu'on a déjà chargé dans le initial load, on skip
            const existing = state.discoveredPeers.get(peerId);
            if (existing && existing.via === 'firebase') {
                console.log(`⏭️  Peer already loaded (${peerId})`);
                return;
            }

            if (peerId === state.myPeerId) {
                console.log(`⏭️  Skipping self (${peerId})`);
                return; // Nous-mêmes
            }
            if (!peerId.startsWith('PT-')) {
                console.log(`⏭️  Skipping invalid peer ID (${peerId})`);
                return;
            }

            console.log(`🔥 Firebase (new): Peer découvert: ${data.name} (${peerId})`);

            handleFirebasePeerDiscovered(peerId, data);
        });

        // Peer modifié (changement de nom)
        peersRef.on('child_changed', (snapshot) => {
            const peerId = snapshot.key;
            const data = snapshot.val();

            if (peerId === state.myPeerId) return;

            const existing = state.discoveredPeers.get(peerId);
            if (existing && data.name) {
                existing.name = data.name;
                existing.lastSeen = Date.now();
                updateDiscoveredPeersList();
            }
        });

        // Peer supprimé (déconnexion)
        peersRef.on('child_removed', (snapshot) => {
            const peerId = snapshot.key;
            console.log(`🔥 Firebase: Peer déconnecté: ${peerId}`);

            const existing = state.discoveredPeers.get(peerId);
            if (existing) {
                existing.online = false;
                existing.connectable = false;
                updateDiscoveredPeersList();
            }
        });

        console.log('🔥 Firebase: Écoute des peers activée');
    }

    // Gérer un peer découvert via Firebase
    async function handleFirebasePeerDiscovered(peerId, data) {
        console.log(`🔍 handleFirebasePeerDiscovered called:`, { peerId, data });

        const now = Date.now();

        // Ajouter aux discovered peers
        const existing = state.discoveredPeers.get(peerId);
        console.log(`📊 Existing peer in state?`, existing ? 'Yes' : 'No');

        if (!existing) {
            const peerInfo = {
                name: data.name || 'Utilisateur',
                lastSeen: now,
                lastHeartbeat: data.timestamp || now,
                connectable: true,
                online: true,
                via: 'firebase'
            };

            console.log(`➕ Adding new peer to state.discoveredPeers:`, peerInfo);
            state.discoveredPeers.set(peerId, peerInfo);
            console.log(`📈 Total discovered peers:`, state.discoveredPeers.size);

            showToast(`${data.name || 'Nouvel utilisateur'} en ligne!`, 'info');

            console.log(`🖥️  Calling updateDiscoveredPeersList()...`);
            updateDiscoveredPeersList();

            // Sauvegarder comme bootstrap peer
            saveAsBootstrapPeer(peerId);

            // Connexion automatique si pas déjà connecté
            if (!state.connections.has(peerId) && !state.pendingConnections.has(peerId)) {
                setTimeout(() => {
                    console.log(`🔗 Firebase: Connexion automatique à ${peerId}`);
                    connectToPeer(peerId);
                }, 1000);
            }
        } else {
            console.log(`🔄 Updating existing peer`);
            existing.lastSeen = now;
            existing.online = true;
            existing.connectable = true;
            if (data.name && data.name !== 'Utilisateur') {
                existing.name = data.name;
            }
            updateDiscoveredPeersList();
        }
    }

    // Mettre à jour le nom dans Firebase quand il change
    function updateFirebaseName(newName) {
        if (firebaseMyRef && FIREBASE_ENABLED) {
            firebaseMyRef.update({ name: newName });
        }
    }

    // ============================================
    // AUTOMATIC PEER DISCOVERY (Global Discovery Room)
    // ============================================

    // GLOBAL DISCOVERY ROOM - All users auto-join this virtual room for peer discovery
    const DISCOVERY_ROOM_ID = 'PT-DISCOVERY-GLOBAL-v1';

    async function discoverPeers() {
        if (!state.peer || !state.myPeerId) return;

        // Strategy 1: Try server API (if available)
        try {
            const savedConfig = localStorage.getItem('signalingConfig');
            let apiUrl;

            if (savedConfig) {
                const config = JSON.parse(savedConfig);
                const protocol = config.port === 443 ? 'https' : 'http';
                const path = config.path || '/';
                apiUrl = `${protocol}://${config.host}:${config.port}${path}peerjs/peers`;
            } else {
                apiUrl = 'https://0.peerjs.com/peerjs/peers';
            }

            // console.log('🔍 Trying server discovery from:', apiUrl);

            const response = await fetch(apiUrl, {
                method: 'GET',
                headers: { 'Accept': 'application/json' }
            });

            if (response.ok) {
                const peers = await response.json();
                const now = Date.now();
                let newPeersFound = 0;

                for (const peerId of peers) {
                    if (peerId === state.myPeerId) continue;
                    if (!peerId.startsWith('PT-')) continue;

                    const existing = state.discoveredPeers.get(peerId);
                    if (!existing) {
                        state.discoveredPeers.set(peerId, {
                            name: 'Utilisateur',
                            lastSeen: now,
                            lastHeartbeat: now,
                            connectable: true,
                            via: 'server'
                        });
                        newPeersFound++;
                    } else {
                        existing.lastSeen = now;
                    }
                }

                if (newPeersFound > 0) {
                    console.log(`✅ Server discovery: ${newPeersFound} peer(s) found`);
                    updateDiscoveredPeersList();

                    // Auto-connect to newly discovered peers
                    const peersToConnect = Array.from(state.discoveredPeers.keys()).filter(peerId =>
                        !state.connections.has(peerId) &&
                        !state.pendingConnections.has(peerId)
                    );

                    for (const peerId of peersToConnect.slice(0, 3)) {
                        console.log('🔗 Auto-connecting to:', peerId);
                        await connectToPeer(peerId);
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
            }
        } catch (error) {
            // Silently fail - server discovery is optional
        }

        // Strategy 2: Use Global Discovery Room (always active)
        // This ensures discovery works even without server API
        announcePresenceToDiscoveryRoom();

        // Cleanup old peers
        const now = Date.now();
        const timeout = 60000;
        for (const [peerId, info] of state.discoveredPeers.entries()) {
            if (now - info.lastSeen > timeout && !state.connections.has(peerId)) {
                state.discoveredPeers.delete(peerId);
            }
        }

        updateDiscoveredPeersList();
    }

    // Announce our presence to the discovery room via all connected peers
    function announcePresenceToDiscoveryRoom() {
        const announcement = {
            type: 'discovery_announcement',
            peerId: state.myPeerId,
            name: state.myName,
            timestamp: Date.now()
        };

        // Send to all connected peers
        state.connections.forEach(({ conn }) => {
            try {
                conn.send(announcement);
            } catch (err) {
                console.warn('Failed to send discovery announcement:', err);
            }
        });

        // Also add ourselves to the discovered peers list
        state.discoveredPeers.set(state.myPeerId, {
            name: state.myName,
            lastSeen: Date.now(),
            lastHeartbeat: Date.now(),
            connectable: false, // Can't connect to ourselves
            via: 'self'
        });
    }

    // Handle discovery announcement from other peers
    function handleDiscoveryAnnouncement(data, fromPeerId) {
        const { peerId, name, timestamp } = data;
        const now = Date.now();

        if (peerId === state.myPeerId) return;
        if (!peerId || !peerId.startsWith('PT-')) return;

        console.log(`📡 Discovered peer via announcement: ${name} (${peerId})`);

        const existing = state.discoveredPeers.get(peerId);
        if (!existing) {
            state.discoveredPeers.set(peerId, {
                name: name || 'Utilisateur',
                lastSeen: now,
                lastHeartbeat: timestamp || now,
                connectable: true,
                via: fromPeerId
            });

            showToast(`${name || 'Nouvel utilisateur'} découvert!`, 'info');
            updateDiscoveredPeersList();

            // Save as bootstrap peer for future sessions
            saveAsBootstrapPeer(peerId);

            // Try to connect if not already connected
            if (!state.connections.has(peerId) && !state.pendingConnections.has(peerId)) {
                setTimeout(() => {
                    console.log(`🔗 Attempting connection to discovered peer: ${peerId}`);
                    connectToPeer(peerId);
                }, 1000);
            }
        } else {
            existing.lastSeen = now;
            if (name && name !== 'Utilisateur') {
                existing.name = name;
            }
            updateDiscoveredPeersList();
        }
    }

    // Try connecting to bootstrap peers (helps with network cold start)
    async function tryBootstrapPeers() {
        const now = Date.now();

        // Don't retry too often
        if (now - state.lastBootstrapAttempt < 25000) return;
        state.lastBootstrapAttempt = now;

        // If we already have connections, no need for bootstrap
        if (state.connections.size > 0) {
            console.log('Already connected to peers, skipping bootstrap');
            return;
        }

        console.log(`🥾 Attempting bootstrap connection (${state.bootstrapPeers.length} known peers)...`);

        // Try to connect to saved bootstrap peers
        for (const peerId of state.bootstrapPeers) {
            if (peerId === state.myPeerId) continue;
            if (state.connections.has(peerId)) continue;
            if (state.pendingConnections.has(peerId)) continue;

            console.log(`🔗 Bootstrap: connecting to ${peerId}`);
            await connectToPeer(peerId);
            await new Promise(resolve => setTimeout(resolve, 1000));

            // If we got a connection, stop trying more
            if (state.connections.size > 0) {
                console.log('✅ Bootstrap successful, network joined!');
                return;
            }
        }

        if (state.connections.size === 0) {
            console.log('⚠️ No bootstrap peers available. Waiting for manual connection or server discovery...');
        }
    }

    // Save a successful peer as bootstrap peer for future sessions
    function saveAsBootstrapPeer(peerId) {
        if (!peerId || peerId === state.myPeerId) return;
        if (state.bootstrapPeers.includes(peerId)) return;

        state.bootstrapPeers.push(peerId);

        // Keep only last 20 bootstrap peers
        if (state.bootstrapPeers.length > 20) {
            state.bootstrapPeers = state.bootstrapPeers.slice(-20);
        }

        localStorage.setItem('bootstrapPeers', JSON.stringify(state.bootstrapPeers));
        console.log(`💾 Saved ${peerId} as bootstrap peer`);
    }

    // Handle discovery request - send all known peers to requester
    function handleDiscoveryRequest(fromPeerId) {
        console.log(`📨 Received discovery request from ${fromPeerId}`);

        const peerInfo = state.connections.get(fromPeerId);
        if (!peerInfo) return;

        const now = Date.now();

        // Send all our discovered peers (including ourselves)
        const peersToSend = Array.from(state.discoveredPeers.entries())
            .filter(([peerId, info]) => now - info.lastSeen < 60000) // Only active peers
            .map(([peerId, info]) => ({
                peerId,
                name: info.name,
                lastSeen: info.lastSeen,
                timestamp: now
            }));

        // Also include all our active connections not yet in discovered peers
        state.connections.forEach(({ name }, peerId) => {
            if (!peersToSend.find(p => p.peerId === peerId)) {
                peersToSend.push({
                    peerId,
                    name: name || 'Utilisateur',
                    lastSeen: now,
                    timestamp: now
                });
            }
        });

        try {
            peerInfo.conn.send({
                type: 'discovery_response',
                peers: peersToSend,
                timestamp: now
            });
            console.log(`📤 Sent ${peersToSend.length} peers to ${fromPeerId}`);
        } catch (err) {
            console.warn('Failed to send discovery response:', err);
        }
    }

    // Handle discovery response - process received peer list
    async function handleDiscoveryResponse(data, fromPeerId) {
        if (!data.peers || !Array.isArray(data.peers)) return;

        const now = Date.now();
        let newPeersFound = 0;

        console.log(`📥 Received discovery response from ${fromPeerId} with ${data.peers.length} peers`);

        for (const peerInfo of data.peers) {
            const { peerId, name, lastSeen } = peerInfo;

            if (peerId === state.myPeerId) continue;
            if (!peerId || !peerId.startsWith('PT-')) continue;

            const existing = state.discoveredPeers.get(peerId);
            if (!existing) {
                state.discoveredPeers.set(peerId, {
                    name: name || 'Utilisateur',
                    lastSeen: now,
                    lastHeartbeat: lastSeen || now,
                    connectable: true,
                    via: fromPeerId
                });
                newPeersFound++;

                // Save as bootstrap peer
                saveAsBootstrapPeer(peerId);
            } else {
                existing.lastSeen = now;
                if (name && name !== 'Utilisateur') {
                    existing.name = name;
                }
            }
        }

        if (newPeersFound > 0) {
            console.log(`✨ Discovered ${newPeersFound} new peer(s) via ${fromPeerId}`);
            showToast(`${newPeersFound} nouvel(s) utilisateur(s) découvert(s)!`, 'info');
            updateDiscoveredPeersList();

            // Try to connect to newly discovered peers (max 3 at once)
            const peersToConnect = Array.from(state.discoveredPeers.keys()).filter(peerId =>
                !state.connections.has(peerId) &&
                !state.pendingConnections.has(peerId) &&
                peerId !== state.myPeerId
            );

            for (const peerId of peersToConnect.slice(0, 3)) {
                console.log(`🔗 Connecting to discovered peer: ${peerId}`);
                await connectToPeer(peerId);
                await new Promise(resolve => setTimeout(resolve, 800));
            }
        }
    }

    // Broadcast our peer list to all connected peers (Gossip Protocol)
    function broadcastPeerList() {
        const now = Date.now();

        // Only broadcast every 15 seconds to avoid spam
        if (now - state.lastPeerBroadcast < 15000) return;
        state.lastPeerBroadcast = now;

        const peerList = Array.from(state.discoveredPeers.entries())
            .filter(([peerId, info]) => now - info.lastSeen < 30000) // Only recent peers
            .map(([peerId, info]) => ({
                peerId,
                name: info.name,
                lastSeen: info.lastSeen
            }));

        // Send to all connected peers
        state.connections.forEach(({ conn }) => {
            try {
                conn.send({
                    type: 'peer_list',
                    peers: peerList,
                    version: state.peerListVersion,
                    sender: state.myName
                });
            } catch (err) {
                console.warn('Failed to broadcast peer list:', err);
            }
        });

        console.log(`📡 Broadcasted peer list (${peerList.length} peers) to ${state.connections.size} connections`);
    }

    // Handle received peer list from other peers
    function handlePeerListMessage(data, fromPeerId) {
        if (!data.peers || !Array.isArray(data.peers)) return;

        const now = Date.now();
        let newPeersFound = 0;

        data.peers.forEach(peerInfo => {
            const { peerId, name, lastSeen } = peerInfo;

            if (peerId === state.myPeerId) return;
            if (!peerId.startsWith('PT-')) return;

            const existing = state.discoveredPeers.get(peerId);
            if (!existing) {
                state.discoveredPeers.set(peerId, {
                    name: name || 'Utilisateur',
                    lastSeen: now,
                    lastHeartbeat: lastSeen || now,
                    connectable: true,
                    via: fromPeerId
                });
                newPeersFound++;

                // Try to connect to newly discovered peer
                if (!state.connections.has(peerId) && !state.pendingConnections.has(peerId)) {
                    setTimeout(() => connectToPeer(peerId), 1000);
                }
            } else {
                existing.lastSeen = now;
                if (name && name !== 'Utilisateur') {
                    existing.name = name;
                }
            }
        });

        if (newPeersFound > 0) {
            console.log(`📬 Received ${newPeersFound} new peer(s) from ${fromPeerId}`);
            state.peerListVersion++;
            updateDiscoveredPeersList();
        }
    }

    // Send heartbeat to all connected peers
    function sendHeartbeat() {
        const now = Date.now();

        state.connections.forEach(({ conn, name }) => {
            try {
                conn.send({
                    type: 'heartbeat',
                    timestamp: now,
                    name: state.myName,
                    peerId: state.myPeerId
                });
            } catch (err) {
                console.warn('Heartbeat send failed:', err);
            }
        });

        // Update our own entry in discovered peers
        state.discoveredPeers.set(state.myPeerId, {
            name: state.myName,
            lastSeen: now,
            lastHeartbeat: now,
            connectable: true,
            via: 'self'
        });
    }

    // Handle heartbeat from peer
    function handleHeartbeat(data, fromPeerId) {
        const now = Date.now();

        const peerInfo = state.discoveredPeers.get(fromPeerId);
        if (peerInfo) {
            peerInfo.lastHeartbeat = now;
            peerInfo.lastSeen = now;
            if (data.name) {
                peerInfo.name = data.name;
            }
        } else {
            state.discoveredPeers.set(fromPeerId, {
                name: data.name || 'Utilisateur',
                lastSeen: now,
                lastHeartbeat: now,
                connectable: true,
                via: 'heartbeat'
            });
        }

        updateDiscoveredPeersList();
    }

    // Update UI with all discovered peers
    function updateDiscoveredPeersList() {
        console.log(`🔄 updateDiscoveredPeersList() called`);
        console.log(`📊 state.discoveredPeers size:`, state.discoveredPeers.size);
        console.log(`📊 state.discoveredPeers content:`, Array.from(state.discoveredPeers.entries()));

        const now = Date.now();
        const allPeersBeforeFilter = Array.from(state.discoveredPeers.entries());
        console.log(`📋 All peers before filter:`, allPeersBeforeFilter);

        const allPeers = allPeersBeforeFilter
            .filter(([peerId, info]) => {
                const timeDiff = now - info.lastSeen;
                const isRecent = timeDiff < 60000; // Active in last 60s
                console.log(`⏰ Peer ${peerId}: lastSeen=${info.lastSeen}, timeDiff=${timeDiff}ms, isRecent=${isRecent}`);
                return isRecent;
            })
            .map(([peerId, info]) => ({
                peerId,
                name: info.name,
                connected: state.connections.has(peerId),
                pending: state.pendingConnections.has(peerId),
                lastSeen: info.lastSeen
            }))
            .sort((a, b) => {
                // Sort: connected first, then by last seen
                if (a.connected && !b.connected) return -1;
                if (!a.connected && b.connected) return 1;
                return b.lastSeen - a.lastSeen;
            });

        console.log(`📋 All peers after filter and map:`, allPeers);
        console.log(`🔢 Number of peers to display:`, allPeers.length);

        // Update the main users list
        const usersListElement = document.getElementById('main-connected-users-list');
        console.log(`🎯 users-list element found:`, !!usersListElement);

        if (usersListElement) {
            if (allPeers.length === 0) {
                console.log(`📝 Setting users-list to empty state message`);
                usersListElement.innerHTML = `
                    <div style="color:#64748b;font-size:0.85rem;text-align:center;padding:20px;">
                        🔍 Recherche d'utilisateurs en ligne...<br>
                        <small style="margin-top:8px;display:block;">Découverte automatique active</small>
                    </div>
                `;
                console.log(`✅ Empty state HTML set`);
            } else {
                console.log(`📝 Setting users-list with ${allPeers.length} peer(s)`);
                usersListElement.innerHTML = allPeers.map(peer => `
                    <div class="peer-item ${peer.connected ? 'connected' : ''}" style="cursor:pointer;" onclick="window.connectToPeer('${peer.peerId}')">
                        <div class="peer-avatar">${(peer.name || '?')[0].toUpperCase()}</div>
                        <div class="peer-details">
                            <div class="peer-name">${escapeHtml(peer.name || 'Utilisateur')}</div>
                            <div class="peer-status ${peer.connected ? 'online' : ''}">
                                <span class="status-dot"></span>
                                ${peer.connected ? 'Connecté' : peer.pending ? 'Connexion...' : 'En ligne'}
                            </div>
                        </div>
                        ${!peer.connected && !peer.pending ? `
                            <button class="peer-action-btn" onclick="event.stopPropagation(); window.connectToPeer('${peer.peerId}')" title="Se connecter">
                                ➕
                            </button>
                        ` : ''}
                    </div>
                `).join('');
                console.log(`✅ Peer list HTML set successfully`);
            }
        } else {
            console.error(`❌ users-list element NOT FOUND in DOM!`);
        }

        // Update header with peer count
        const onlineCount = allPeers.length;
        const connectedCount = allPeers.filter(p => p.connected).length;

        console.log(`📊 Peer counts: online=${onlineCount}, connected=${connectedCount}`);

        const statusElement = document.getElementById('discovery-status');
        console.log(`🎯 discovery-status element found:`, !!statusElement);

        if (statusElement) {
            const statusText = `${onlineCount} en ligne • ${connectedCount} connecté(s)`;
            console.log(`📝 Setting status text: "${statusText}"`);
            statusElement.textContent = statusText;
            console.log(`✅ Status text updated`);
        } else {
            console.error(`❌ discovery-status element NOT FOUND in DOM!`);
        }

        console.log(`✅ updateDiscoveredPeersList() completed`);
    }

    // ============================================
    // CONNECTION HANDLING
    // ============================================
    async function handleIncomingConnection(conn) {
        console.log('Incoming connection from:', conn.peer);

        if (state.connections.has(conn.peer)) {
            conn.close();
            return;
        }

        setupConnection(conn);
    }

    async function connectToPeer(peerId) {
        if (state.connections.has(peerId) || peerId === state.myPeerId) {
            return;
        }

        try {
            const conn = state.peer.connect(peerId, {
                reliable: true,
                serialization: 'json'
            });
            setupConnection(conn);
        } catch (error) {
            console.error('Connection error:', error);
        }
    }

    async function setupConnection(conn) {
        const peerId = conn.peer;

        state.pendingConnections.set(peerId, { conn, name: 'Connexion...' });
        updatePeersList();

        conn.on('open', async () => {
            // Send handshake with public key
            const publicKeyBase64 = await Crypto.exportPublicKey(state.myKeyPair.publicKey);
            conn.send({
                type: 'handshake',
                name: state.myName,
                publicKey: publicKeyBase64,
                room: state.currentRoom
            });
        });

        conn.on('data', async (data) => {
            await handleIncomingData(conn, data);
        });

        conn.on('close', () => {
            handlePeerDisconnect(peerId);
        });

        conn.on('error', (err) => {
            console.error('Connection error:', err);
            console.error('Connection error details for peer', peerId, ':', {
                type: err.type,
                message: err.message
            });
            // Don't immediately disconnect on data channel errors during file transfer
            if (err.type === 'data-channel-error' && state.fileTransfers.size > 0) {
                console.log('Data channel error during file transfer - ignoring');
                return;
            }
            // Don't disconnect on peer-unavailable if we have active file transfers
            if (err.type === 'peer-unavailable' && state.fileTransfers.size > 0) {
                console.warn('Peer unavailable during file transfer - may be temporary');
                return;
            }
            handlePeerDisconnect(peerId);
        });
    }

    async function handleIncomingData(conn, data) {
        const peerId = conn.peer;

        // Directly process JSON messages (no binary parsing needed)
        switch (data.type) {
            case 'handshake':
                await handleHandshake(conn, data);
                break;

            case 'peer_list':
                handlePeerListMessage(data, peerId);
                break;

            case 'heartbeat':
                handleHeartbeat(data, peerId);
                break;

            case 'discovery_announcement':
                handleDiscoveryAnnouncement(data, peerId);
                break;

            case 'discovery_request':
                handleDiscoveryRequest(peerId);
                break;

            case 'discovery_response':
                handleDiscoveryResponse(data, peerId);
                break;

            case 'encrypted':
                await handleEncryptedMessage(peerId, data);
                break;

            case 'file-start':
                handleFileStart(peerId, data);
                break;

            case 'file-chunk':
                handleFileChunk(peerId, data);
                break;

            case 'file-end':
                await handleFileEnd(peerId, data);
                break;

            case 'ping':
                // Respond to ping with pong
                const peerInfo = state.connections.get(peerId);
                if (peerInfo && peerInfo.conn) {
                    peerInfo.conn.send({ type: 'pong', timestamp: data.timestamp });
                }
                break;

            case 'pong':
                // Update last activity for this peer
                const info = state.connections.get(peerId);
                if (info) {
                    info.lastSeen = Date.now();
                }
                break;

            case 'typing':
                handleTypingIndicator(peerId, data);
                break;

            case 'peer-list':
                handlePeerList(data);
                break;

            case 'kick-user':
                handleKickUser(data);
                break;

            case 'ban-user':
                handleBanUser(data);
                break;

            case 'report-user':
                handleReportUser(data);
                break;

            case 'vote-kick':
                handleVoteKick(data);
                break;

            case 'admin-assign':
                handleAdminAssign(data);
                break;

            case 'admin-revoke':
                handleAdminRevoke(data);
                break;

            case 'join-request':
                handleJoinRequest(data);
                break;

            case 'join-approved':
                handleJoinApproved(data);
                break;

            case 'join-rejected':
                handleJoinRejected(data);
                break;

            case 'friend-request':
                handleFriendRequest(data);
                break;

            case 'friend-accepted':
                handleFriendAccepted(data);
                break;

            case 'dm':
                handleDirectMessage(data);
                break;

            case 'dmRejected':
                handleDmRejected(data);
                break;

            case 'dmRead':
                handleDmRead(data);
                break;
        }
    }

    async function handleHandshake(conn, data) {
        const peerId = conn.peer;
        const username = data.name || 'Anonyme';

        try {
            // Check if this is a name update (no public key) or initial handshake
            const existingConnection = state.connections.get(peerId);
            
            if (data.publicKey && !existingConnection) {
                // Initial handshake - import public key and derive shared key
                const peerPublicKey = await Crypto.importPublicKey(data.publicKey);
                const sharedKey = await Crypto.deriveSharedKey(state.myKeyPair.privateKey, peerPublicKey);

                // Store new connection info
                const connectionInfo = {
                    conn,
                    name: username,
                    username: username,
                    publicKey: peerPublicKey,
                    sharedKey,
                    lastSeen: Date.now()
                };

                state.connections.set(peerId, connectionInfo);
                state.connectionsByUsername.set(username, connectionInfo);

                // Store mapping username <-> peerId
                state.usernameToPeerId.set(username, peerId);
                state.peerIdToUsername.set(peerId, username);

                // Update discovered peers with actual name
                const discoveredPeer = state.discoveredPeers.get(peerId);
                if (discoveredPeer) {
                    discoveredPeer.name = username;
                    discoveredPeer.lastSeen = Date.now();
                } else {
                    state.discoveredPeers.set(peerId, {
                        name: username,
                        lastSeen: Date.now(),
                        lastHeartbeat: Date.now(),
                        connectable: true,
                        via: 'connection'
                    });
                }

                // Save previous peerIds for this username
                if (!state.myPreviousPeerIds.includes(peerId)) {
                    state.myPreviousPeerIds.push(peerId);
                    localStorage.setItem('myPreviousPeerIds', JSON.stringify(state.myPreviousPeerIds));
                }

                state.pendingConnections.delete(peerId);
                updatePeersList();
                updateDiagnostics();
                updateConnectedUsersList();
                updateFriendsList();

                // Save as bootstrap peer for future sessions
                saveAsBootstrapPeer(peerId);

                appendSystemMessage(`${username} a rejoint le salon (E2E activé)`);
                showToast(`${username} connecté`, 'success');

                // Immediately request discovery announcements from new peer
                setTimeout(() => {
                    announcePresenceToDiscoveryRoom();
                    // Also request their peer list
                    conn.send({
                        type: 'discovery_request',
                        timestamp: Date.now()
                    });
                }, 500);

                // If we're the room creator, share the peer list
                if (state.isRoomCreator) {
                    broadcastPeerList();
                }

                // Enable chat if not already
                enableChat();
            } else if (existingConnection) {
                // Name update - just update the name and mappings
                existingConnection.name = username;
                existingConnection.username = username;
                existingConnection.lastSeen = Date.now();

                // Update mappings
                state.usernameToPeerId.set(username, peerId);
                state.peerIdToUsername.set(peerId, username);

                updatePeersList();
            } else {
                // Invalid handshake - no connection and no public key
                console.warn('Invalid handshake: no existing connection and no public key');
                conn.close();
            }

        } catch (error) {
            console.error('Handshake error:', error);
            conn.close();
        }
    }

    function handlePeerDisconnect(peerId) {
        const peerInfo = state.connections.get(peerId);
        const name = peerInfo?.name || 'Un utilisateur';

        state.connections.delete(peerId);
        state.pendingConnections.delete(peerId);
        state.typingPeers.delete(peerId);

        updatePeersList();
        updateTypingIndicator();
        updateDiagnostics();
        updateConnectedUsersList();
        updateFriendsList();

        appendSystemMessage(`${name} a quitté le salon`);
    }

    function broadcastPeerList() {
        const peerIds = Array.from(state.connections.keys());
        state.connections.forEach(({ conn }) => {
            conn.send({
                type: 'peer-list',
                peers: peerIds
            });
        });
    }

    function handlePeerList(data) {
        // Connect to any peers we're not already connected to
        data.peers.forEach(peerId => {
            if (!state.connections.has(peerId) && peerId !== state.myPeerId) {
                connectToPeer(peerId);
            }
        });
    }

    // ============================================
    // MODERATION HANDLERS
    // ============================================
    function handleKickUser(data) {
        const { targetPeerId, initiatorId, reason } = data;

        // Check if we have permission
        if (!canModerate()) {
            appendSystemMessage('⚠️ Action de modération ignorée - permissions insuffisantes', 'warning');
            return;
        }

        const peerInfo = state.connections.get(targetPeerId);
        if (peerInfo) {
            appendSystemMessage(`🚪 ${peerInfo.name} a été expulsé par l'administrateur`, 'warning');
            showToast(`${peerInfo.name} expulsé`, 'info');

            // Disconnect the user
            peerInfo.conn.send({
                type: 'kicked',
                reason: reason || 'Expulsion par administrateur',
                initiatorId
            });
            peerInfo.conn.close();
            state.connections.delete(targetPeerId);
            updatePeersList();
        }
    }

    function handleBanUser(data) {
        const { targetPeerId, initiatorId, reason } = data;

        // Check if we have permission
        if (!canModerate()) {
            appendSystemMessage('⚠️ Action de modération ignorée - permissions insuffisantes', 'warning');
            return;
        }

        const peerInfo = state.connections.get(targetPeerId);
        if (peerInfo) {
            appendSystemMessage(`🚫 ${peerInfo.name} a été banni du salon`, 'error');
            showToast(`${peerInfo.name} banni`, 'error');

            // Add to banned list
            const roomId = state.currentRoom?.id;
            if (roomId && !state.bannedUsers.has(roomId)) {
                state.bannedUsers.set(roomId, new Set());
            }
            if (roomId) {
                state.bannedUsers.get(roomId).add(targetPeerId);
            }

            // Disconnect the user
            peerInfo.conn.send({
                type: 'banned',
                reason: reason || 'Bannissement par administrateur',
                initiatorId
            });
            peerInfo.conn.close();
            state.connections.delete(targetPeerId);
            updatePeersList();
        }
    }

    function handleReportUser(data) {
        const { reporterId, targetPeerId, reason } = data;
        const reporterInfo = state.connections.get(reporterId);
        const targetInfo = state.connections.get(targetPeerId);

        if (!reporterInfo || !targetInfo) return;

        // Only admins/creator can see reports
        if (canModerate()) {
            appendSystemMessage(`🚨 Signalement: ${reporterInfo.name} signale ${targetInfo.name}`, 'warning');
            if (reason) {
                appendSystemMessage(`   Raison: ${reason}`, 'warning');
            }
            showToast('Nouveau signalement reçu', 'warning');
        }

        // Store report
        const roomId = state.currentRoom?.id;
        if (roomId) {
            if (!state.reportedUsers.has(roomId)) {
                state.reportedUsers.set(roomId, new Map());
            }
            const reports = state.reportedUsers.get(roomId);
            const existingReport = reports.get(targetPeerId);
            if (existingReport) {
                existingReport.count++;
                existingReport.reasons.push(reason);
            } else {
                reports.set(targetPeerId, {
                    reporterId,
                    reason,
                    count: 1,
                    reasons: [reason],
                    timestamp: Date.now()
                });
            }
        }
    }

    function handleVoteKick(data) {
        const { voteId, targetPeerId, voterId, vote } = data;

        // Check if we're the one being voted on
        if (targetPeerId === state.myPeerId) {
            // We cannot veto our own expulsion
            const peerInfo = state.connections.get(voterId);
            appendSystemMessage(`🗳 ${peerInfo?.name || 'Quelqu\'un'} a voté pour votre expulsion`, 'warning');

            // If vote passes (more than half of participants)
            const totalParticipants = state.connections.size + 1;
            const activeVote = state.activeVotes.get(voteId);
            if (activeVote && activeVote.votes.size >= Math.ceil(totalParticipants / 2)) {
                appendSystemMessage(`💔 Vous avez été expulsé par vote collectif`, 'error');
                // Send acceptance and disconnect
                state.connections.forEach(({ conn }) => {
                    conn.send({ type: 'vote-result', voteId, result: 'accepted', targetPeerId });
                });
                leaveRoom();
            }
            return;
        }

        // If we're admin/creator, handle veto
        if (canModerate()) {
            handleVoteResult(data);
            return;
        }

        // Regular participant - handle voting
        const activeVote = state.activeVotes.get(voteId);
        if (!activeVote) {
            // Create new vote
            state.activeVotes.set(voteId, {
                targetPeerId,
                votes: new Set([voterId]),
                expiresAt: Date.now() + 300000 // 5 minutes
            });
            const targetInfo = state.connections.get(targetPeerId);
            const voterInfo = state.connections.get(voterId);
            appendSystemMessage(`🗳 Vote d'expulsion lancé par ${voterInfo?.name || 'inconnu'} contre ${targetInfo?.name || 'inconnu'}`, 'warning');
            showToast('Vote d\'expulsion en cours - répondez par /oui ou /non', 'info');
        } else if (!activeVote.votes.has(voterId)) {
            // Add vote
            activeVote.votes.add(voterId);
            const votersCount = activeVote.votes.size;
            const totalParticipants = state.connections.size + 1;

            // Check if vote passes
            if (votersCount >= Math.ceil(totalParticipants / 2)) {
                appendSystemMessage(`✅ Vote accepté - Expulsion en cours`, 'warning');
                broadcastMessage({
                    type: 'vote-result',
                    voteId,
                    result: 'accepted',
                    targetPeerId
                });
            }
        }
    }

    function handleVoteResult(data) {
        const { voteId, result, targetPeerId } = data;

        if (!canModerate()) {
            // Not admin - regular participant
            if (result === 'rejected') {
                appendSystemMessage(`✅ L'expulsion a été rejetée par l'administrateur`, 'success');
                showToast('Vote annulé par l\'administrateur', 'success');
            }
            return;
        }

        // Admin/creator - veto authority
        if (result === 'accepted') {
            const targetInfo = state.connections.get(targetPeerId);
            if (confirm(`Le vote pour expulser ${targetInfo?.name || 'ce participant'} a réussi. Voulez-vous l'accepter ou le veto ?`)) {
                // Accept vote
                appendSystemMessage(`✅ Vote accepté - ${targetInfo?.name || 'Participant'} expulsé`, 'warning');
                if (targetInfo) {
                    targetInfo.conn.send({
                        type: 'kicked',
                        reason: 'Expulsion par vote collectif',
                        initiatorId: 'vote'
                    });
                    targetInfo.conn.close();
                    state.connections.delete(targetPeerId);
                    updatePeersList();
                }
                broadcastMessage({
                    type: 'vote-result',
                    voteId,
                    result: 'accepted',
                    targetPeerId
                });
            } else {
                // Veto vote
                appendSystemMessage(`🛡️ Veto appliqué - Expulsion annulée`, 'info');
                broadcastMessage({
                    type: 'vote-result',
                    voteId,
                    result: 'rejected',
                    targetPeerId
                });
            }
        }

        state.activeVotes.delete(voteId);
    }

    function handleAdminAssign(data) {
        const { targetPeerId, adminId } = data;
        const targetInfo = state.connections.get(targetPeerId);
        const adminInfo = state.connections.get(adminId);

        if (!targetInfo || !adminInfo) return;

        // Update role
        targetInfo.role = 'admin';

        // Store admin
        const roomId = state.currentRoom?.id;
        if (roomId) {
            if (!state.roomAdmins.has(roomId)) {
                state.roomAdmins.set(roomId, new Set());
            }
            state.roomAdmins.get(roomId).add(targetPeerId);
        }

        appendSystemMessage(`👑 ${adminInfo.name} a nommé ${targetInfo.name} administrateur`, 'success');
        showToast(`${targetInfo.name} est maintenant administrateur`, 'success');
        updatePeersList();
    }

    function handleAdminRevoke(data) {
        const { targetPeerId, revokerId } = data;
        const targetInfo = state.connections.get(targetPeerId);
        const revokerInfo = state.connections.get(revokerId);

        if (!targetInfo || !revokerInfo) return;

        // Update role
        targetInfo.role = 'participant';

        // Remove from admins
        const roomId = state.currentRoom?.id;
        if (roomId && state.roomAdmins.has(roomId)) {
            state.roomAdmins.get(roomId).delete(targetPeerId);
        }

        appendSystemMessage(`⚠️ ${revokerInfo.name} a révoqué les droits d'admin de ${targetInfo.name}`, 'warning');
        showToast(`${targetInfo.name} n'est plus administrateur`, 'warning');
        updatePeersList();
    }

    // Helper functions
    function canModerate() {
        return state.myRole === 'creator' || state.myRole === 'admin';
    }

    function broadcastMessage(message) {
        state.connections.forEach(({ conn }) => {
            if (conn.open) {
                conn.send(message);
            }
        });
    }

    // ============================================
    // MESSAGING
    // ============================================
    async function sendMessage() {
        const content = elements.messageInput.value.trim();
        if (!content || state.connections.size === 0) return;

        const timestamp = new Date().toISOString();
        const messageData = {
            type: 'message',
            content,
            sender: state.myName,
            timestamp
        };

        // Encrypt and send to all peers
        for (const [peerId, { conn, sharedKey }] of state.connections) {
            try {
                const encrypted = await Crypto.encrypt(sharedKey, messageData);
                conn.send({ type: 'encrypted', payload: encrypted });
            } catch (error) {
                console.error('Encryption error:', error);
            }
        }

        // Display locally
        appendMessage(content, 'sent', state.myName, timestamp, true);

        // Clear input
        elements.messageInput.value = '';
        elements.messageInput.style.height = 'auto';

        // Stop typing indicator
        sendTypingStatus(false);
    }

    async function handleEncryptedMessage(peerId, data) {
        const peerInfo = state.connections.get(peerId);
        if (!peerInfo) return;

        try {
            const decrypted = await Crypto.decrypt(peerInfo.sharedKey, data.payload);

            if (decrypted.type === 'message') {
                appendMessage(decrypted.content, 'received', decrypted.sender, decrypted.timestamp, true);
                playNotificationSound();
            }
        } catch (error) {
            console.error('Decryption error:', error);
        }
    }

    function appendMessage(content, type, sender, timestamp, encrypted = false) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;

        const time = timestamp ? formatTime(new Date(timestamp)) : formatTime(new Date());

        if (type === 'system') {
            messageDiv.textContent = content;
        } else {
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span class="message-sender">${escapeHtml(sender)}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-content">${escapeHtml(content)}</div>
                ${encrypted ? '<div class="message-encryption"><svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg> Chiffré E2E</div>' : ''}
            `;
        }

        elements.messagesContainer.appendChild(messageDiv);
        scrollToBottom();
    }

    function appendSystemMessage(content) {
        appendMessage(content, 'system');
    }

    // ============================================
    // FILE TRANSFER
    // ============================================
    async function handleFileSelect(e) {
        const files = e.target.files;
        if (!files.length) return;

        // Check context (DM or room)
        const context = e.target.dataset.context;
        const recipient = e.target.dataset.recipient;

        console.log('handleFileSelect - context:', context, 'recipient:', recipient);

        for (const file of files) {
            if (file.size > CONFIG.maxFileSize) {
                showToast(`${file.name} est trop volumineux (max 100MB)`, 'error');
                continue;
            }

            if (context === 'dm' && recipient) {
                // Send file via DM
                console.log('Sending file via DM to:', recipient);
                try {
                    await sendFileViaDM(file, recipient);
                } catch (error) {
                    console.error('Error sending file via DM:', error);
                    showToast('Erreur lors de l\'envoi du fichier via DM', 'error');
                }
            } else {
                // Send file to room (existing logic)
                if (state.connections.size === 0) {
                    showToast('Aucun utilisateur connecté', 'warning');
                    continue;
                }
                console.log('Sending file to room');
                try {
                    await sendFile(file);
                } catch (error) {
                    console.error('Error sending file to room:', error);
                    showToast('Erreur lors de l\'envoi du fichier au salon', 'error');
                }
            }
        }

        // Clear context
        delete e.target.dataset.context;
        delete e.target.dataset.recipient;
        elements.fileInput.value = '';
    }

    async function sendFile(file) {
        const transferId = generateId(12);
        const arrayBuffer = await file.arrayBuffer();

        // Create message element with progress
        const messageId = 'file-' + transferId;
        appendFileMessage(messageId, file.name, file.size, file.type, 'sent', 0);

        // Send file to all peers
        let peersSent = 0;
        let peersFailed = 0;
        
        for (const [peerId, { conn, sharedKey, name }] of state.connections) {
            try {
                // Check if connection is still open
                if (!conn || !conn.open) {
                    console.warn(`Skipping peer ${peerId} (${name}): connection not open`);
                    peersFailed++;
                    continue;
                }
                
                // Encrypt the file
                const { iv, encrypted } = await Crypto.encryptFile(sharedKey, arrayBuffer);

                // Send file metadata
                conn.send({
                    type: 'file-start',
                    transferId,
                    fileName: file.name,
                    fileSize: encrypted.length,
                    fileType: file.type,
                    iv: Array.from(iv),
                    sender: state.myName,
                    timestamp: new Date().toISOString()
                });

                // Send chunks - use base64 encoding (like old version)
                const chunkSize = 4096; // 4KB chunks
                const totalChunks = Math.ceil(encrypted.length / chunkSize);

                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, encrypted.length);
                    const chunk = encrypted.slice(start, end);

                    // Convert to base64 to avoid array size issues
                    const chunkBase64 = btoa(String.fromCharCode(...chunk));

                    conn.send({
                        type: 'file-chunk',
                        transferId,
                        chunkIndex: i,
                        totalChunks,
                        data: chunkBase64
                    });

                    // Update progress
                    const progress = ((i + 1) / totalChunks) * 100;
                    updateFileProgress(messageId, progress);

                    // Add small delay between chunks to avoid connection overload
                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                // Add delay before sending completion
                await new Promise(resolve => setTimeout(resolve, 100));

                // Send completion
                conn.send({
                    type: 'file-end',
                    transferId
                });
                peersSent++;

            } catch (error) {
                console.error('File send error to peer', peerId, ':', error);
                peersFailed++;
            }
        }
        
        console.log(`File transfer complete: ${peersSent} peers succeeded, ${peersFailed} peers failed`);

        updateFileProgress(messageId, 100, true);

        // Create preview and download link for sender
        const blob = new Blob([arrayBuffer], { type: file.type });
        const url = URL.createObjectURL(blob);
        updateFileDownload(messageId, url, file.name, file.type, blob);
    }

    async function sendFileViaDM(file, recipient) {
        console.log('sendFileViaDM called with recipient:', recipient);
        console.log('Available connections:', Array.from(state.connections.keys()));
        
        const connection = state.connections.get(recipient);
        if (!connection) {
            console.error('Connection not found for recipient:', recipient);
            showToast('Non connecté à ce contact', 'warning');
            return;
        }
        if (!connection.conn.open) {
            console.error('Connection not open for recipient:', recipient);
            showToast('Connexion fermée avec ce contact', 'warning');
            return;
        }
        
        console.log('Connection found and open, starting file transfer');

        const transferId = generateId(12);
        const arrayBuffer = await file.arrayBuffer();

        // Create message element with progress
        const messageId = 'file-' + transferId;
        appendDmFileMessage(messageId, file.name, file.size, file.type, 'sent', 0);

        try {
            // Encrypt the file
            const { iv, encrypted } = await Crypto.encryptFile(connection.sharedKey, arrayBuffer);

                // Send file metadata
            connection.conn.send({
                type: 'file-start',
                transferId,
                fileName: file.name,
                fileSize: encrypted.length,
                fileType: file.type,
                iv: Array.from(iv),
                sender: state.myName,
                timestamp: new Date().toISOString()
            });

            // Send chunks - use base64 encoding (like old version)
            const chunkSize = 4096;
            const totalChunks = Math.ceil(encrypted.length / chunkSize);

            for (let i = 0; i < totalChunks; i++) {
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize, encrypted.length);
                const chunk = encrypted.slice(start, end);

                // Convert to base64 to avoid array size issues
                const chunkBase64 = btoa(String.fromCharCode(...chunk));

                connection.conn.send({
                    type: 'file-chunk',
                    transferId,
                    chunkIndex: i,
                    totalChunks,
                    data: chunkBase64
                });

                const progress = ((i + 1) / totalChunks) * 100;
                updateDmFileProgress(messageId, progress);

                await new Promise(resolve => setTimeout(resolve, 10));
            }

            await new Promise(resolve => setTimeout(resolve, 100));

            connection.conn.send({
                type: 'file-end',
                transferId
            });

            updateDmFileProgress(messageId, 100, true);

            // Create preview and download link for sender
            const blob = new Blob([arrayBuffer], { type: file.type });
            const url = URL.createObjectURL(blob);
            updateDmFileDownload(messageId, url, file.name, file.type, blob);

        } catch (error) {
            console.error('File send error:', error);
            showToast(`Erreur d'envoi de ${file.name}`, 'error');
        }
    }

    function handleFileStart(peerId, data) {
        // Calculate expected chunks based on 4KB chunk size
        const chunkSize = 4096;
        
        // Use isDM flag from sender if available, otherwise check active conversation
        const isDM = data.isDM !== undefined ? data.isDM : (state.activeDMConversation === peerId);
        
        state.fileTransfers.set(data.transferId, {
            chunks: new Array(Math.ceil(data.fileSize / chunkSize)),
            metadata: data,
            receivedChunks: 0,
            peerId,
            isDM
        });

        const messageId = 'file-' + data.transferId;
        if (isDM) {
            appendDmFileMessage(messageId, data.fileName, data.fileSize, data.fileType, 'received', 0, data.sender, data.timestamp);
        } else {
            appendFileMessage(messageId, data.fileName, data.fileSize, data.fileType, 'received', 0, data.sender, data.timestamp);
        }
    }

    function handleFileChunk(peerId, data) {
        const transfer = state.fileTransfers.get(data.transferId);
        if (!transfer) return;

        // data.data may be a base64 string (old path) or a Uint8Array (binary path)
        let chunk;
        if (typeof data.data === 'string') {
            const binaryString = atob(data.data);
            chunk = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                chunk[i] = binaryString.charCodeAt(i);
            }
        } else if (data.data instanceof Uint8Array) {
            chunk = data.data;
        } else if (data.data && data.data.byteLength) {
            chunk = new Uint8Array(data.data);
        } else {
            console.warn('Received file chunk in unknown format', data);
            return;
        }

        transfer.chunks[data.chunkIndex] = chunk;
        transfer.receivedChunks++;

        const progress = (transfer.receivedChunks / data.totalChunks) * 100;
        
        if (transfer.isDM) {
            updateDmFileProgress('file-' + data.transferId, progress);
        } else {
            updateFileProgress('file-' + data.transferId, progress);
        }
    }

    async function handleFileEnd(peerId, data) {
        const transfer = state.fileTransfers.get(data.transferId);
        if (!transfer) return;

        try {
            // Combine chunks - filter out null/undefined chunks
            const validChunks = transfer.chunks.filter(chunk => chunk !== null && chunk !== undefined);
            const totalLength = validChunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const combined = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of validChunks) {
                combined.set(chunk, offset);
                offset += chunk.length;
            }

            // Decrypt file
            const peerInfo = state.connections.get(peerId);
            if (!peerInfo) return;

            const iv = new Uint8Array(transfer.metadata.iv);
            const decrypted = await Crypto.decryptFile(peerInfo.sharedKey, iv, combined);

            // Create blob and download link
            const blob = new Blob([decrypted], { type: transfer.metadata.fileType });
            const url = URL.createObjectURL(blob);

            if (transfer.isDM) {
                updateDmFileDownload('file-' + data.transferId, url, transfer.metadata.fileName, transfer.metadata.fileType, blob);
            } else {
                updateFileDownload('file-' + data.transferId, url, transfer.metadata.fileName, transfer.metadata.fileType, blob);
            }

            playNotificationSound();

        } catch (error) {
            console.error('File receive error:', error);
            showToast('Erreur de réception du fichier', 'error');
        }

        state.fileTransfers.delete(data.transferId);
    }

    function appendFileMessage(messageId, fileName, fileSize, fileType, type, progress, sender = state.myName, timestamp = null) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        messageDiv.id = messageId;

        const time = timestamp ? formatTime(new Date(timestamp)) : formatTime(new Date());
        const isImage = fileType.startsWith('image/');

        messageDiv.innerHTML = `
            <div class="message-header">
                <span class="message-sender">${escapeHtml(sender)}</span>
                <span class="message-time">${time}</span>
            </div>
            <div class="file-message">
                <div class="file-info">
                    <div class="file-icon">
                        ${isImage ?
                            '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>' :
                            '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline></svg>'
                        }
                    </div>
                    <div class="file-details">
                        <div class="file-name">${escapeHtml(fileName)}</div>
                        <div class="file-size">${formatFileSize(fileSize)}</div>
                    </div>
                </div>
                <div class="file-progress">
                    <div class="file-progress-bar" style="width: ${progress}%"></div>
                </div>
                <div class="file-actions"></div>
            </div>
            <div class="message-encryption"><svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg> Fichier chiffré E2E</div>
        `;

        elements.messagesContainer.appendChild(messageDiv);
        scrollToBottom();
    }

    function updateFileProgress(messageId, progress, complete = false) {
        const el = document.getElementById(messageId);
        if (!el) return;

        const progressBar = el.querySelector('.file-progress-bar');
        if (progressBar) {
            progressBar.style.width = progress + '%';
        }

        if (complete) {
            const progressEl = el.querySelector('.file-progress');
            if (progressEl) progressEl.style.display = 'none';
        }
    }

    function updateFileDownload(messageId, url, fileName, fileType, blob) {
        const el = document.getElementById(messageId);
        if (!el) return;

        const actionsEl = el.querySelector('.file-actions');
        const progressEl = el.querySelector('.file-progress');

        if (progressEl) progressEl.style.display = 'none';

        // Show image preview if applicable
        if (fileType.startsWith('image/')) {
            const preview = document.createElement('img');
            preview.src = url;
            preview.className = 'image-preview';
            preview.onclick = () => {
                elements.modalImage.src = url;
                elements.imageModal.classList.add('show');
            };
            actionsEl.before(preview);
        }

        actionsEl.innerHTML = `
            <button class="file-download">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                Télécharger
            </button>
        `;
        const downloadBtn = actionsEl.querySelector('.file-download');
        downloadBtn.addEventListener('click', () => {
            downloadFile(url, fileName);
        });
    }

    function downloadFile(url, fileName) {
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
    }
    window.downloadFile = downloadFile;

    function appendDmFileMessage(messageId, fileName, fileSize, fileType, type, progress, sender = state.myName, timestamp = null) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        messageDiv.id = messageId;

        const timeStr = new Date(timestamp || Date.now()).toLocaleTimeString('fr-FR', {
            hour: '2-digit',
            minute: '2-digit'
        });
        const isImage = fileType.startsWith('image/');

        messageDiv.innerHTML = `
            <div class="file-message">
                <div class="file-info">
                    <div class="file-icon">
                        ${isImage ?
                            '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>' :
                            '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline></svg>'
                        }
                    </div>
                    <div class="file-details">
                        <div class="file-name">${escapeHtml(fileName)}</div>
                        <div class="file-size">${formatFileSize(fileSize)}</div>
                    </div>
                </div>
                <div class="file-progress">
                    <div class="file-progress-bar" style="width: ${progress}%"></div>
                </div>
                <div class="file-actions"></div>
            </div>
            <div class="message-time">${timeStr}</div>
        `;

        elements.dmMessages.appendChild(messageDiv);
        scrollToBottom(elements.dmMessages);
    }

    function updateDmFileProgress(messageId, progress, complete = false) {
        const el = document.getElementById(messageId);
        if (!el) return;

        const progressBar = el.querySelector('.file-progress-bar');
        if (progressBar) {
            progressBar.style.width = progress + '%';
        }

        if (complete) {
            const progressEl = el.querySelector('.file-progress');
            if (progressEl) progressEl.style.display = 'none';
        }
    }

    function updateDmFileDownload(messageId, url, fileName, fileType, blob) {
        const el = document.getElementById(messageId);
        if (!el) return;

        const actionsEl = el.querySelector('.file-actions');
        const progressEl = el.querySelector('.file-progress');

        if (progressEl) progressEl.style.display = 'none';

        if (fileType.startsWith('image/')) {
            const preview = document.createElement('img');
            preview.src = url;
            preview.className = 'image-preview';
            preview.onclick = () => {
                elements.modalImage.src = url;
                elements.imageModal.classList.add('show');
            };
            actionsEl.before(preview);
        }

        actionsEl.innerHTML = `
            <button class="file-download">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                Télécharger
            </button>
        `;
        const downloadBtn = actionsEl.querySelector('.file-download');
        downloadBtn.addEventListener('click', () => {
            downloadFile(url, fileName);
        });
    }

    // ============================================
    // TYPING INDICATOR
    // ============================================
    function handleTyping() {
        // Auto-resize
        elements.messageInput.style.height = 'auto';
        elements.messageInput.style.height = Math.min(elements.messageInput.scrollHeight, 120) + 'px';

        if (!state.isTyping) {
            state.isTyping = true;
            sendTypingStatus(true);
        }

        clearTimeout(state.typingTimer);
        state.typingTimer = setTimeout(() => {
            state.isTyping = false;
            sendTypingStatus(false);
        }, CONFIG.typingTimeout);
    }

    function sendTypingStatus(isTyping) {
        state.connections.forEach(({ conn }) => {
            conn.send({
                type: 'typing',
                isTyping,
                name: state.myName
            });
        });
    }

    function handleTypingIndicator(peerId, data) {
        if (data.isTyping) {
            state.typingPeers.add(data.name || 'Quelqu\'un');
        } else {
            state.typingPeers.delete(data.name || 'Quelqu\'un');
        }
        updateTypingIndicator();
    }

    function updateTypingIndicator() {
        if (state.typingPeers.size > 0) {
            const names = Array.from(state.typingPeers);
            let text;
            if (names.length === 1) {
                text = `${names[0]} écrit...`;
            } else if (names.length === 2) {
                text = `${names[0]} et ${names[1]} écrivent...`;
            } else {
                text = `${names.length} personnes écrivent...`;
            }
            elements.typingNames.textContent = text;
            elements.typingIndicator.classList.add('active');
        } else {
            elements.typingIndicator.classList.remove('active');
        }
    }

    // ============================================
    // UI UPDATES
    // ============================================
    function updatePeersList() {
        updateParticipantsList();
        updateDiscoveredPeersList(); // Also update the discovered peers list
    }

    function updateParticipantsList() {
        // Get all peers
        let allPeers = [
            ...Array.from(state.connections.entries()).map(([id, info]) => ({ id, ...info, connected: true })),
            ...Array.from(state.pendingConnections.entries()).map(([id, info]) => ({ id, ...info, connected: false }))
        ];

        // Filter by current room members if in a room
        if (state.currentRoom && state.currentRoom.members) {
            allPeers = allPeers.filter(peer => {
                const peerUsername = peer.name || peer.username;
                return state.currentRoom.members.includes(peerUsername);
            });
        }

        // Check if current user can moderate
        const canMod = canModerate();
        const isCreator = state.myRole === 'creator';

        if (allPeers.length === 0) {
            elements.peersList.innerHTML = `
                <div style="color:#64748b;font-size:0.85rem;text-align:center;padding:20px;">
                    ${state.currentRoom ? 'Aucun membre du salon connecté' : 'Aucun participant connecté'}
                </div>
            `;
        } else {
            elements.peersList.innerHTML = allPeers.map(peer => {
                // Don't show moderation actions for yourself or for creators (only creator can moderate another creator)
                const canModerateThisPeer = canMod && peer.connected && (peer.role !== 'creator' || isCreator);
                const isAdmin = peer.role === 'admin';

                return `
                <div class="peer-item ${peer.connected ? 'connected' : ''}" style="display:flex;align-items:center;gap:12px;">
                    <div class="peer-avatar">${(peer.name || '?')[0].toUpperCase()}</div>
                    <div class="peer-details" style="flex:1;min-width:0;">
                        <div class="peer-name">
                            ${escapeHtml(peer.name || 'Connexion...')}
                            ${peer.role === 'admin' ? '<span class="role-badge admin">👑 Admin</span>' : ''}
                            ${peer.role === 'creator' ? '<span class="role-badge creator">🎯 Créateur</span>' : ''}
                        </div>
                        <div class="peer-id">${escapeHtml(peer.id)}</div>
                    </div>
                    ${!peer.connected ? '<span class="peer-status">Connexion...</span>' : ''}
                    ${canModerateThisPeer ? `
                        <div class="peer-actions" style="display:flex;gap:4px;flex-shrink:0;">
                            ${!isAdmin && isCreator ? `
                                <button class="action-btn-small" onclick="promoteToAdmin('${peer.id}')" title="Promouvoir admin">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                                        <path d="M2 17l10 5 10-5M2 12l10 5 10-5"></path>
                                    </svg>
                                </button>
                            ` : ''}
                            ${isAdmin && isCreator ? `
                                <button class="action-btn-small" onclick="revokeAdmin('${peer.id}')" title="Retirer admin">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="3 6 5 6 21 6"></polyline>
                                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                        <line x1="10" y1="11" x2="10" y2="17"></line>
                                        <line x1="14" y1="11" x2="14" y2="17"></line>
                                    </svg>
                                </button>
                            ` : ''}
                            <button class="action-btn-small warn" onclick="kickParticipant('${peer.id}')" title="Expulser">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                                    <polyline points="16 17 21 12 16 7"></polyline>
                                    <line x1="21" y1="12" x2="9" y2="12"></line>
                                </svg>
                            </button>
                            <button class="action-btn-small danger" onclick="banParticipant('${peer.id}')" title="Bannir">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>
                                </svg>
                            </button>
                        </div>
                    ` : ''}
                </div>
            `;
            }).join('');
        }

        // Update participants count
        const connectedCount = state.connections.size;
        const totalCount = allPeers.length;
        elements.participantsCount.textContent = connectedCount;
        if (elements.headerParticipants) {
            elements.headerParticipants.textContent = connectedCount;
        }
    }

    // ============================================
    // PARTICIPANT MODERATION ACTIONS
    // ============================================
    window.kickParticipant = function(peerId) {
        if (!canModerate()) {
            showToast('Permissions insuffisantes', 'error');
            return;
        }

        const peerInfo = state.connections.get(peerId);
        if (!peerInfo) {
            showToast('Participant non trouvé', 'error');
            return;
        }

        const reason = prompt(`Expulser ${peerInfo.name} ?\nRaison (optionnel):`);
        if (reason === null) return; // User canceled

        broadcastMessage({
            type: 'kick-user',
            targetPeerId: peerId,
            initiatorId: state.myPeerId,
            reason: reason || 'Expulsion par modérateur'
        });

        // Also handle it locally
        handleKickUser({
            targetPeerId: peerId,
            initiatorId: state.myPeerId,
            reason: reason || 'Expulsion par modérateur'
        });

        showToast(`${peerInfo.name} expulsé`, 'success');
    };

    window.banParticipant = function(peerId) {
        if (!canModerate()) {
            showToast('Permissions insuffisantes', 'error');
            return;
        }

        const peerInfo = state.connections.get(peerId);
        if (!peerInfo) {
            showToast('Participant non trouvé', 'error');
            return;
        }

        if (!confirm(`Bannir définitivement ${peerInfo.name} ?\nIl ne pourra plus rejoindre ce salon.`)) {
            return;
        }

        const reason = prompt('Raison du bannissement (optionnel):');
        if (reason === null) return; // User canceled

        broadcastMessage({
            type: 'ban-user',
            targetPeerId: peerId,
            initiatorId: state.myPeerId,
            reason: reason || 'Bannissement par modérateur'
        });

        // Also handle it locally
        handleBanUser({
            targetPeerId: peerId,
            initiatorId: state.myPeerId,
            reason: reason || 'Bannissement par modérateur'
        });

        showToast(`${peerInfo.name} banni`, 'success');
    };

    window.promoteToAdmin = function(peerId) {
        if (state.myRole !== 'creator') {
            showToast('Seul le créateur peut promouvoir des admins', 'error');
            return;
        }

        const peerInfo = state.connections.get(peerId);
        if (!peerInfo) {
            showToast('Participant non trouvé', 'error');
            return;
        }

        if (!confirm(`Promouvoir ${peerInfo.name} en tant qu'administrateur ?`)) {
            return;
        }

        broadcastMessage({
            type: 'admin-assign',
            targetPeerId: peerId,
            creatorId: state.myPeerId
        });

        // Update locally
        peerInfo.role = 'admin';
        if (state.currentRoom) {
            if (!state.currentRoom.admins.includes(peerInfo.name)) {
                state.currentRoom.admins.push(peerInfo.name);
            }
        }

        updateParticipantsList();
        showToast(`${peerInfo.name} promu administrateur`, 'success');
        appendSystemMessage(`👑 ${peerInfo.name} est maintenant administrateur`);
    };

    window.revokeAdmin = function(peerId) {
        if (state.myRole !== 'creator') {
            showToast('Seul le créateur peut révoquer des admins', 'error');
            return;
        }

        const peerInfo = state.connections.get(peerId);
        if (!peerInfo) {
            showToast('Participant non trouvé', 'error');
            return;
        }

        if (!confirm(`Retirer les droits d'administrateur à ${peerInfo.name} ?`)) {
            return;
        }

        broadcastMessage({
            type: 'admin-revoke',
            targetPeerId: peerId,
            creatorId: state.myPeerId
        });

        // Update locally
        peerInfo.role = 'participant';
        if (state.currentRoom) {
            const adminIndex = state.currentRoom.admins.indexOf(peerInfo.name);
            if (adminIndex > -1) {
                state.currentRoom.admins.splice(adminIndex, 1);
            }
        }

        updateParticipantsList();
        showToast(`Droits d'admin retirés à ${peerInfo.name}`, 'success');
        appendSystemMessage(`${peerInfo.name} n'est plus administrateur`);
    };

    function enableChat() {
        elements.messageInput.disabled = false;
        elements.messageInput.placeholder = 'Tapez votre message...';
        elements.sendBtn.disabled = false;
    }

    function updateStatusBar(status, message) {
        elements.statusBar.className = 'status-bar ' + status;
        elements.statusBar.innerHTML = status === 'connecting'
            ? `<div class="spinner"></div><span>${message}</span>`
            : `<span>${message}</span>`;
    }

    function toggleMobileSidebar() {
        const sidebar = elements.sidebar;
        const overlay = elements.sidebarOverlay;
        const isShown = sidebar.classList.contains('mobile-show');

        if (isShown) {
            // Hide sidebar
            sidebar.classList.remove('mobile-show');
            overlay.classList.remove('show');
        } else {
            // Show sidebar
            sidebar.classList.add('mobile-show');
            overlay.classList.add('show');
        }
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================
    function generateId(length) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars[Math.floor(Math.random() * chars.length)];
        }
        return result;
    }

    function formatTime(date) {
        return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
    }

    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function scrollToBottom() {
        if (elements.messagesContainer) {
            elements.messagesContainer.scrollTop = elements.messagesContainer.scrollHeight;
        }
    }

    function showToast(message, type = 'info') {
        elements.toast.textContent = message;
        elements.toast.className = `toast ${type} show`;
        setTimeout(() => elements.toast.classList.remove('show'), 3000);
    }

    // ============================================
    // MODERATION ACTIONS
    // ============================================
    function initiateKick(peerId) {
        const peerInfo = state.connections.get(peerId);
        if (!peerInfo) return;

        const reason = prompt(`Raison de l'expulsion de ${peerInfo.name} :`, 'Comportement inapproprié');
        if (reason === null) return;

        broadcastMessage({
            type: 'kick-user',
            targetPeerId: peerId,
            initiatorId: state.myPeerId,
            reason
        });
    }

    function initiateBan(peerId) {
        const peerInfo = state.connections.get(peerId);
        if (!peerInfo) return;

        if (!confirm(`Voulez-vous vraiment bannir ${peerInfo.name} du salon ?`)) return;

        const reason = prompt(`Raison du bannissement de ${peerInfo.name} :`, 'Comportement inapproprié');
        if (reason === null) return;

        broadcastMessage({
            type: 'ban-user',
            targetPeerId: peerId,
            initiatorId: state.myPeerId,
            reason
        });
    }

    function reportUser(peerId) {
        const peerInfo = state.connections.get(peerId);
        if (!peerInfo) return;

        const reason = prompt(`Raison du signalement de ${peerInfo.name} :`, 'Comportement inapproprié');
        if (reason === null) return;

        appendSystemMessage(`🚨 Vous avez signalé ${peerInfo.name} aux administrateurs`, 'info');
        showToast('Signalement envoyé aux administrateurs', 'success');

        broadcastMessage({
            type: 'report-user',
            reporterId: state.myPeerId,
            targetPeerId: peerId,
            reason
        });
    }

    function initiateVote(peerId) {
        const peerInfo = state.connections.get(peerId);
        if (!peerInfo) return;

        const reason = prompt(`Raison du vote d'expulsion contre ${peerInfo.name} :`, 'Comportement inapproprié');
        if (reason === null) return;

        if (!confirm(`Voulez-vous vraiment lancer un vote d'expulsion contre ${peerInfo.name} ? Les participants devront voter avec /oui ou /non`)) return;

        const voteId = generateId(10);
        state.activeVotes.set(voteId, {
            targetPeerId: peerId,
            votes: new Set([state.myPeerId]),
            reason,
            expiresAt: Date.now() + 300000
        });

        appendSystemMessage(`🗳 Vote d'expulsion lancé contre ${peerInfo.name}`, 'warning');
        showToast('Vote d\'expulsion en cours - envoyez /oui ou /non pour voter', 'info');

        broadcastMessage({
            type: 'vote-kick',
            voteId,
            targetPeerId: peerId,
            voterId: state.myPeerId,
            vote: 'initiate',
            reason
        });
    }

    function assignAdmin(peerId) {
        const peerInfo = state.connections.get(peerId);
        if (!peerInfo) return;

        if (!confirm(`Voulez-vous nommer ${peerInfo.name} administrateur ?`)) return;

        appendSystemMessage(`👑 Vous avez nommé ${peerInfo.name} administrateur`, 'success');
        showToast(`${peerInfo.name} est maintenant administrateur`, 'success');

        broadcastMessage({
            type: 'admin-assign',
            targetPeerId: peerId,
            adminId: state.myPeerId
        });

        // Update local
        peerInfo.role = 'admin';
        const roomId = state.currentRoom?.id;
        if (roomId) {
            if (!state.roomAdmins.has(roomId)) {
                state.roomAdmins.set(roomId, new Set());
            }
            state.roomAdmins.get(roomId).add(peerId);
        }
        updatePeersList();
    }

    function revokeAdmin(peerId) {
        const peerInfo = state.connections.get(peerId);
        if (!peerInfo) return;

        if (!confirm(`Voulez-vous révoquer les droits d'admin de ${peerInfo.name} ?`)) return;

        appendSystemMessage(`⬇️ Vous avez révoqué les droits d'admin de ${peerInfo.name}`, 'warning');
        showToast(`${peerInfo.name} n'est plus administrateur`, 'warning');

        broadcastMessage({
            type: 'admin-revoke',
            targetPeerId: peerId,
            revokerId: state.myPeerId
        });

        // Update local
        peerInfo.role = 'participant';
        const roomId = state.currentRoom?.id;
        if (roomId && state.roomAdmins.has(roomId)) {
            state.roomAdmins.get(roomId).delete(peerId);
        }
        updatePeersList();
    }

    function playNotificationSound() {
        try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.frequency.value = 800;
            gain.gain.setValueAtTime(0.1, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
            osc.start();
            osc.stop(ctx.currentTime + 0.15);
        } catch (e) {}
    }

    // Event handlers
    function handleNameChange(e) {
        state.myName = e.target.value.trim() || 'Anonyme';
        localStorage.setItem('peerName', state.myName);

        // Update Firebase
        updateFirebaseName(state.myName);

        // Update all connected peers
        state.connections.forEach(({ conn }) => {
            conn.send({
                type: 'handshake',
                name: state.myName,
                publicKey: null // Don't resend key
            });
        });
    }

    function copyPeerId() {
        if (!state.myPeerId) return;
        navigator.clipboard.writeText(state.myPeerId).then(() => {
            showToast('ID copié !', 'success');
        });
    }

    function handleMessageKeydown(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    }

    function handlePeerError(err) {
        console.error('Peer error:', err);
        console.error('Peer error details:', {
            type: err.type,
            message: err.message,
            stack: err.stack
        });
        let message = 'Erreur de connexion';
        let isCritical = false;

        if (err.type === 'peer-unavailable') {
            message = 'Pair introuvable. Vérifiez l\'ID et réessayez.';
            updateStatusBar('error', message);
            showToast(message, 'error');
            console.warn('Peer unavailable - check if connection exists or peer is online');
        } else if (err.type === 'network' || err.type === 'server-error') {
            // Network errors are usually temporary and don't affect existing P2P connections
            message = 'Erreur réseau temporaire. Connexions P2P actives.';
            console.log('Temporary network error - P2P connections remain active');
            updateStatusBar('connecting', 'Reconnexion au serveur...');
            // Don't show error toast for temporary network issues, but show system message
            appendSystemMessage('⚠️ Erreur de connexion au serveur de signalisation. Les connexions P2P restent actives. Reconnexion en cours...');
        } else if (err.type === 'peer-error') {
            message = 'Erreur de connexion au pair. Vérifiez votre configuration ICE.';
            isCritical = true;
            updateStatusBar('error', message);
            showToast(message, 'error');
        } else if (err.type === 'ssl-unavailable') {
            message = 'Erreur SSL. Vérifiez que vous utilisez HTTPS.';
            isCritical = true;
            updateStatusBar('error', message);
            showToast(message, 'error');
        } else if (err.type === 'server-error') {
            message = 'Erreur du serveur de signalisation.';
            updateStatusBar('error', message);
            showToast(message, 'warning');
        } else {
            message = `Erreur: ${err.type || 'Connexion échouée'}`;
            isCritical = true;
            updateStatusBar('error', message);
            showToast(message, 'error');
        }

        // If critical error, show help message
        if (isCritical) {
            appendSystemMessage('💡 Astuce: Si vous avez des problèmes de connexion, essayez d\'ajouter des serveurs TURN supplémentaires dans les paramètres ⚙️');
        }
    }

    // ============================================
    // MIGRATION FROM PEERID TO USERNAME
    // ============================================

    function migrateOldData() {
        // Load old data if exists
        const oldFriends = localStorage.getItem('friends');
        const oldRooms = localStorage.getItem('privateRooms');
        const oldDirectMessages = localStorage.getItem('directMessages');

        // These are now loaded in state initialization, but we need to migrate them if they use old format
        console.log('Migration: Checking for old format data...');
    }

    // ============================================
    // TABS AND UI MANAGEMENT
    // ============================================

    function switchTab(tab) {
        state.currentTab = tab;

        // Update tab buttons
        elements.roomsTab.classList.toggle('active', tab === 'rooms');
        elements.usersTab.classList.toggle('active', tab === 'users');
        elements.dmTab.classList.toggle('active', tab === 'dm');
        elements.profileTab.classList.toggle('active', tab === 'profile');

        // Update sections
        elements.roomsSection.classList.toggle('active', tab === 'rooms');
        elements.usersSection.classList.toggle('active', tab === 'users');
        elements.dmSection.classList.toggle('active', tab === 'dm');
        elements.profileSection.classList.toggle('active', tab === 'profile');

        // Refresh user list when switching to users tab
        if (tab === 'users') {
            updateConnectedUsersList();
        }
    }

    // ============================================
    // PRIVATE ROOMS SYSTEM
    // ============================================

    function openRoomCreationModal() {
        elements.roomNameInput.value = '';
        elements.roomCreationModal.classList.add('show');
        elements.roomNameInput.focus();
    }

    function closeRoomCreationModal() {
        elements.roomCreationModal.classList.remove('show');
    }

    async function createPrivateRoom() {
        const roomName = elements.roomNameInput.value.trim();
        if (!roomName) {
            showToast('Veuillez entrer un nom pour le salon', 'warning');
            return;
        }

        const room = {
            id: generateRoomId(),
            name: roomName,
            creatorUsername: state.myName,
            admins: [state.myName],           // Stockage par nom d'utilisateur
            members: [state.myName],          // Stockage par nom d'utilisateur
            createdAt: Date.now()
        };

        state.privateRooms.push(room);
        savePrivateRooms();
        closeRoomCreationModal();
        updatePrivateRoomsList();

        showToast(`Salon "${roomName}" créé avec succès !`, 'success');

        // Show room detail
        showRoomDetail(room);
    }

    function refreshRoomsList() {
        // Recharge la liste des salons depuis localStorage
        const savedRooms = JSON.parse(localStorage.getItem('privateRooms') || '[]');
        state.privateRooms = savedRooms;
        updatePrivateRoomsList();
        showToast('Liste des salons actualisée', 'success');
    }

    // Auto-refresh every 30 seconds
    setInterval(() => {
        if (state.currentTab === 'rooms') {
            refreshRoomsList();
        }
    }, 30000);

    function generateRoomId() {
        const prefix = 'RT';
        const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let id = '';
        for (let i = 0; i < 8; i++) {
            id += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return `${prefix}-${id}`;
    }

    function updatePrivateRoomsList() {
        const rooms = state.privateRooms;
        const container = elements.privateRoomsList;
        const isSelectMode = state.roomSelectMode;

        if (rooms.length === 0) {
            container.innerHTML = `
                <div style="color:#64748b;font-size:0.9rem;text-align:center;padding:40px;">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="margin-bottom:12px;">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                        <circle cx="9" cy="7" r="4"></circle>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                    </svg>
                    <p>Aucun salon. Créez-en un ou rejoignez un salon existant.</p>
                </div>
            `;
            // Hide select button and multi-select actions when no rooms
            elements.toggleSelectModeBtn.style.display = 'none';
            elements.multiSelectActions.style.display = 'none';
            return;
        }

        // Show select button when there are rooms
        elements.toggleSelectModeBtn.style.display = '';

        container.innerHTML = rooms.map(room => {
            const memberCount = room.members.length;
            const isCreator = room.creatorUsername === state.myName;
            const isAdmin = room.admins.includes(state.myName);
            const creatorName = room.creatorUsername || 'Inconnu';
            const isSelected = state.selectedRooms.has(room.id);
            const selectableClass = isSelectMode ? 'selectable' : '';
            const selectedClass = isSelected ? 'selected' : '';

            const checkboxHtml = isSelectMode ? `
                <div class="room-card-checkbox">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </div>
            ` : '';

            return `
                <div class="room-card ${selectableClass} ${selectedClass}" data-room-id="${room.id}">
                    ${checkboxHtml}
                    <div class="room-card-header">
                        <span class="room-card-name">${escapeHtml(room.name)}</span>
                        <span class="room-card-badge">${isCreator ? 'Créateur' : isAdmin ? 'Admin' : 'Membre'}</span>
                    </div>
                    <div class="room-card-info">ID: ${room.id}</div>
                    <div class="room-card-info" style="font-size:0.75rem;">Créateur: ${escapeHtml(creatorName)}</div>
                    <div class="room-card-participants">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                        </svg>
                        ${memberCount} membre${memberCount > 1 ? 's' : ''}
                    </div>
                </div>
            `;
        }).join('');

        // Add click listeners
        container.querySelectorAll('.room-card').forEach(card => {
            card.addEventListener('click', () => {
                const roomId = card.dataset.roomId;

                if (state.roomSelectMode) {
                    // Toggle selection
                    toggleRoomSelection(roomId);
                } else {
                    const room = state.privateRooms.find(r => r.id === roomId);
                    if (room) {
                        showRoomDetail(room);
                    }
                }
            });
        });
    }

    // Room multi-select functions
    function toggleRoomSelectMode() {
        state.roomSelectMode = true;
        state.selectedRooms.clear();
        elements.toggleSelectModeBtn.style.display = 'none';
        elements.multiSelectActions.style.display = 'flex';
        updateSelectionCount();
        updatePrivateRoomsList();
    }

    function cancelRoomSelectMode() {
        state.roomSelectMode = false;
        state.selectedRooms.clear();
        elements.toggleSelectModeBtn.style.display = '';
        elements.multiSelectActions.style.display = 'none';
        updatePrivateRoomsList();
    }

    function toggleRoomSelection(roomId) {
        if (state.selectedRooms.has(roomId)) {
            state.selectedRooms.delete(roomId);
        } else {
            state.selectedRooms.add(roomId);
        }
        updateSelectionCount();
        // Update just the card's visual state without full re-render
        const card = document.querySelector(`.room-card[data-room-id="${roomId}"]`);
        if (card) {
            card.classList.toggle('selected', state.selectedRooms.has(roomId));
        }
    }

    function updateSelectionCount() {
        const count = state.selectedRooms.size;
        elements.selectionCount.textContent = `${count} sélectionné${count > 1 ? 's' : ''}`;
        elements.deleteSelectedRoomsBtn.disabled = count === 0;
    }

    function deleteSelectedRooms() {
        if (state.selectedRooms.size === 0) {
            showToast('Aucun salon sélectionné', 'warning');
            return;
        }

        // Check which rooms the user can delete (only rooms they created) or leave
        const roomsToDelete = [];
        const roomsToLeave = [];

        state.selectedRooms.forEach(roomId => {
            const room = state.privateRooms.find(r => r.id === roomId);
            if (room) {
                if (room.creatorUsername === state.myName) {
                    roomsToDelete.push(room);
                } else {
                    roomsToLeave.push(room);
                }
            }
        });

        const deleteCount = roomsToDelete.length;
        const leaveCount = roomsToLeave.length;

        let confirmMessage = '';
        if (deleteCount > 0 && leaveCount > 0) {
            confirmMessage = `Vous allez supprimer ${deleteCount} salon${deleteCount > 1 ? 's' : ''} (dont vous êtes créateur) et quitter ${leaveCount} salon${leaveCount > 1 ? 's' : ''}.\n\nContinuer ?`;
        } else if (deleteCount > 0) {
            confirmMessage = `Êtes-vous sûr de vouloir supprimer définitivement ${deleteCount} salon${deleteCount > 1 ? 's' : ''} ?\n\nCette action est irréversible.`;
        } else if (leaveCount > 0) {
            confirmMessage = `Êtes-vous sûr de vouloir quitter ${leaveCount} salon${leaveCount > 1 ? 's' : ''} ?`;
        }

        if (!confirm(confirmMessage)) return;

        // Delete rooms where user is creator
        roomsToDelete.forEach(room => {
            const index = state.privateRooms.findIndex(r => r.id === room.id);
            if (index > -1) {
                state.privateRooms.splice(index, 1);
            }
        });

        // Leave rooms where user is not creator
        roomsToLeave.forEach(room => {
            const memberIndex = room.members.indexOf(state.myName);
            if (memberIndex > -1) {
                room.members.splice(memberIndex, 1);
            }
            const adminIndex = room.admins.indexOf(state.myName);
            if (adminIndex > -1) {
                room.admins.splice(adminIndex, 1);
            }
        });

        savePrivateRooms();
        cancelRoomSelectMode();

        let message = '';
        if (deleteCount > 0 && leaveCount > 0) {
            message = `${deleteCount} salon${deleteCount > 1 ? 's supprimés' : ' supprimé'} et ${leaveCount} salon${leaveCount > 1 ? 's quittés' : ' quitté'}`;
        } else if (deleteCount > 0) {
            message = `${deleteCount} salon${deleteCount > 1 ? 's supprimés' : ' supprimé'}`;
        } else {
            message = `${leaveCount} salon${leaveCount > 1 ? 's quittés' : ' quitté'}`;
        }
        showToast(message, 'success');
    }

    function showRoomDetail(room) {
        state.currentRoom = room;
        state.isRoomCreator = room.creatorUsername === state.myName;
        state.myRole = room.creatorUsername === state.myName ? 'creator' :
                      room.admins.includes(state.myName) ? 'admin' : 'participant';

        // Check if user is already a member (by username)
        const isMember = room.members.includes(state.myName);

        // Hide rooms list, show detail
        document.getElementById('rooms-list-view').style.display = 'none';
        elements.roomDetail.classList.add('active');

        // Update header
        elements.detailRoomName.textContent = room.name;
        elements.detailRoomId.textContent = `ID: ${room.id}`;

        // Show/hide leave and delete buttons based on role
        elements.leaveRoomBtn.style.display = (isMember && !state.isRoomCreator) ? 'inline-flex' : 'none';
        elements.deleteRoomBtn.style.display = state.isRoomCreator ? 'inline-flex' : 'none';

        if (!isMember) {
            // User is not a member - show join request view
            showRoomJoinRequestView(room);
        } else {
            // User is a member - show normal room view
            showRoomNormalView(room);
        }
    }

    function showRoomJoinRequestView(room) {
        // Hide chat elements, show join request interface
        elements.messagesContainer.innerHTML = `
            <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;padding:40px;text-align:center;">
                <svg width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom:20px;color:#fbbf24;">
                    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                </svg>
                <h2 style="color:#e2e8f0;margin-bottom:15px;">Salon privé</h2>
                <p style="color:#94a3b8;margin-bottom:30px;max-width:400px;">
                    Ce salon est privé. Vous devez envoyer une demande au créateur pour y accéder.
                </p>
                <div style="background:rgba(99,179,237,0.1);border:1px solid rgba(99,179,237,0.2);border-radius:12px;padding:20px;margin-bottom:25px;max-width:400px;width:100%;">
                    <h3 style="color:#63b3ed;font-size:1rem;margin-bottom:10px;">${escapeHtml(room.name)}</h3>
                    <p style="color:#64748b;font-size:0.85rem;margin-bottom:5px;">Créé par :</p>
                    <p style="color:#94a3b8;font-weight:600;">${escapeHtml(room.creatorUsername || 'Inconnu')}</p>
                </div>
                <div style="display:flex;gap:15px;justify-content:center;">
                    <button id="send-join-request-btn" class="btn btn-primary" style="padding:12px 30px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:6px;">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                            <polyline points="22 4 12 14.01 9 11.01"></polyline>
                        </svg>
                        Envoyer une demande
                    </button>
                    <button id="cancel-join-request-btn" class="btn btn-secondary" style="padding:12px 30px;">
                        Annuler
                    </button>
                </div>
                <div style="background:rgba(30,41,59,0.8);border:1px solid rgba(255,255,255,0.1);border-radius:8px;padding:15px;margin-top:20px;max-width:400px;width:100%;">
                    <p style="color:#64748b;font-size:0.75rem;margin-bottom:8px;">Vos informations à partager avec le créateur :</p>
                    <p style="color:#e2e8f0;font-size:0.85rem;margin-bottom:4px;">Nom : <strong style="color:#63b3ed;">${escapeHtml(state.myName)}</strong></p>
                    <p style="color:#e2e8f0;font-size:0.85rem;">ID : <strong style="color:#63b3ed;">${state.myPeerId}</strong></p>
                </div>
            </div>
        `;

        // Add event listeners
        setTimeout(() => {
            const sendBtn = document.getElementById('send-join-request-btn');
            const cancelBtn = document.getElementById('cancel-join-request-btn');

            if (sendBtn) {
                sendBtn.onclick = () => sendJoinRequestToCreator(room);
            }
            if (cancelBtn) {
                cancelBtn.onclick = backToRoomsList;
            }
        }, 100);

        // Hide join requests section and chat input for non-members
        elements.joinRequestsSection.style.display = 'none';

        // Hide chat input area completely
        const inputArea = elements.messageInput ? elements.messageInput.closest('.input-area') : null;
        if (inputArea) {
            inputArea.style.display = 'none';
        }
        if (elements.messageInput) {
            elements.messageInput.disabled = true;
        }
        if (elements.sendBtn) {
            elements.sendBtn.disabled = true;
        }
        if (elements.attachBtn) {
            elements.attachBtn.disabled = true;
        }
    }

    function sendJoinRequestToCreator(room) {
        // Find the room creator among connected peers by username
        let creatorConnection = null;
        let creatorPeerId = null;

        for (const [peerId, connectionInfo] of state.connections) {
            if (connectionInfo.name === room.creatorUsername) {
                creatorConnection = connectionInfo;
                creatorPeerId = peerId;
                break;
            }
        }

        if (!creatorConnection || !creatorConnection.conn.open) {
            // Creator is not online
            elements.messagesContainer.innerHTML = `
                <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;padding:40px;text-align:center;">
                    <svg width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom:20px;color:#f59e0b;">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <h3 style="color:#f59e0b;margin-bottom:15px;">Créateur hors ligne</h3>
                    <p style="color:#94a3b8;margin-bottom:25px;">
                        Le créateur du salon <strong style="color:#63b3ed;">${escapeHtml(room.creatorUsername)}</strong> n'est pas connecté actuellement.<br>
                        Réessayez quand il sera en ligne.
                    </p>
                    <button class="btn btn-secondary" onclick="backToRoomsList()" style="padding:10px 25px;">
                        Retour aux salons
                    </button>
                </div>
            `;
            return;
        }

        // Send join request via P2P
        creatorConnection.conn.send({
            type: 'join-request',
            roomId: room.id,
            peerId: state.myPeerId,
            name: state.myName
        });

        showToast('Demande envoyée au créateur du salon', 'success');

        // Show confirmation
        elements.messagesContainer.innerHTML = `
            <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;padding:40px;text-align:center;">
                <svg width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom:20px;color:#34d399;">
                    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                    <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
                <h3 style="color:#34d399;margin-bottom:15px;">Demande envoyée !</h3>
                <p style="color:#94a3b8;margin-bottom:25px;">
                    Le créateur du salon a reçu votre demande. Vous serez notifié(e) quand elle sera acceptée.
                </p>
                <button class="btn btn-secondary" onclick="backToRoomsList()" style="padding:10px 25px;">
                    Retour aux salons
                </button>
            </div>
        `;
    }

    function showRoomNormalView(room) {
        // Show/hide join requests section based on role
        const isAdmin = state.myRole === 'creator' || state.myRole === 'admin';
        const pendingRequests = state.pendingJoinRequests.get(room.id) || [];

        if (isAdmin && pendingRequests.length > 0) {
            elements.joinRequestsSection.style.display = 'block';
            updateJoinRequestsList(room.id);
        } else {
            elements.joinRequestsSection.style.display = 'none';
        }

        // Enable chat and ensure input area is visible
        if (elements.messageInput) {
            elements.messageInput.disabled = false;
            elements.messageInput.placeholder = 'Écrivez votre message...';
            elements.messageInput.style.display = 'block';
        }
        if (elements.sendBtn) {
            elements.sendBtn.disabled = false;
            elements.sendBtn.style.display = 'flex';
        }
        if (elements.attachBtn) {
            elements.attachBtn.disabled = false;
            elements.attachBtn.style.display = 'flex';
        }

        // Ensure input area container is visible
        const inputArea = elements.messageInput ? elements.messageInput.closest('.input-area') : null;
        if (inputArea) {
            inputArea.style.display = 'block';
        }

        // Clear and update messages
        elements.messagesContainer.innerHTML = `<div class="message system">Bienvenue dans le salon "${escapeHtml(room.name)}" !</div>`;

        // Update participants list
        updateParticipantsList();
    }

    function backToRoomsList() {
        state.currentRoom = null;
        document.getElementById('rooms-list-view').style.display = 'block';
        elements.roomDetail.classList.remove('active');
    }

    function copyRoomAccessId() {
        if (!state.currentRoom) return;

        navigator.clipboard.writeText(state.currentRoom.id)
            .then(() => showToast('ID du salon copié !', 'success'))
            .catch(() => showToast('Erreur lors de la copie', 'error'));
    }

    function leaveRoom() {
        if (!state.currentRoom) return;

        const roomName = state.currentRoom.name;
        if (!confirm(`Êtes-vous sûr de vouloir quitter le salon "${roomName}" ?`)) return;

        // Remove user from members (by username)
        const memberIndex = state.currentRoom.members.indexOf(state.myName);
        if (memberIndex > -1) {
            state.currentRoom.members.splice(memberIndex, 1);
        }

        // Also remove from admins if applicable (by username)
        const adminIndex = state.currentRoom.admins.indexOf(state.myName);
        if (adminIndex > -1) {
            state.currentRoom.admins.splice(adminIndex, 1);
        }

        // Update the room in state.privateRooms
        const roomIndex = state.privateRooms.findIndex(r => r.id === state.currentRoom.id);
        if (roomIndex > -1) {
            state.privateRooms[roomIndex] = state.currentRoom;
        }

        savePrivateRooms();
        updatePrivateRoomsList();
        backToRoomsList();

        showToast(`Vous avez quitté le salon "${roomName}"`, 'success');
    }

    function deleteRoom() {
        if (!state.currentRoom || !state.isRoomCreator) return;

        const roomName = state.currentRoom.name;
        if (!confirm(`Êtes-vous sûr de vouloir supprimer définitivement le salon "${roomName}" ?\n\nCette action est irréversible.`)) return;

        // Remove room from state
        const roomIndex = state.privateRooms.findIndex(r => r.id === state.currentRoom.id);
        if (roomIndex > -1) {
            state.privateRooms.splice(roomIndex, 1);
        }

        savePrivateRooms();
        updatePrivateRoomsList();
        backToRoomsList();

        showToast(`Salon "${roomName}" supprimé`, 'success');
    }

    // ============================================
    // JOIN REQUESTS SYSTEM
    // ============================================

    function requestToJoinRoom() {
        const roomId = elements.joinRoomIdInput.value.trim().toUpperCase();
        if (!roomId) {
            showToast('Veuillez entrer l\'ID du salon', 'warning');
            return;
        }

        // Check if we're already in this room
        const existingRoom = state.privateRooms.find(r => r.id === roomId);
        if (existingRoom) {
            showToast('Vous êtes déjà membre de ce salon', 'warning');
            return;
        }

        // Store the pending join request
        state.pendingJoinRequest = {
            roomId,
            timestamp: Date.now()
        };

        elements.joinRoomIdInput.value = '';

        // Try to find the room creator among connected peers by sending a room info request
        // First, broadcast a room-info-request to all connected peers
        let requestSent = false;

        for (const [peerId, connectionInfo] of state.connections) {
            if (connectionInfo.conn && connectionInfo.conn.open) {
                connectionInfo.conn.send({
                    type: 'join-request',
                    roomId: roomId,
                    peerId: state.myPeerId,
                    name: state.myName
                });
                requestSent = true;
            }
        }

        if (requestSent) {
            showToast('Demande de rejoindre envoyée aux utilisateurs connectés', 'success');

            // Show confirmation modal
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:1000;';
            modal.innerHTML = `
                <div style="background:rgba(15,23,42,0.95);padding:30px;border-radius:20px;max-width:400px;text-align:center;">
                    <svg width="50" height="50" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom:15px;color:#34d399;">
                        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                        <polyline points="22 4 12 14.01 9 11.01"></polyline>
                    </svg>
                    <h3 style="color:#e2e8f0;margin-bottom:15px;">Demande envoyée</h3>
                    <p style="color:#94a3b8;margin-bottom:20px;">
                        Votre demande pour rejoindre le salon <strong style="color:#63b3ed;">${roomId}</strong> a été envoyée.
                    </p>
                    <p style="color:#64748b;font-size:0.85rem;margin-bottom:20px;">
                        Vous serez notifié(e) si un administrateur du salon accepte votre demande.
                    </p>
                    <button id="close-modal-btn" class="btn btn-primary" style="padding:10px 30px;">
                        Compris
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            modal.querySelector('#close-modal-btn').onclick = () => modal.remove();
        } else {
            // No connected peers
            showToast('Aucun utilisateur connecté pour recevoir la demande', 'warning');

            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:1000;';
            modal.innerHTML = `
                <div style="background:rgba(15,23,42,0.95);padding:30px;border-radius:20px;max-width:400px;text-align:center;">
                    <svg width="50" height="50" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom:15px;color:#f59e0b;">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <h3 style="color:#f59e0b;margin-bottom:15px;">Aucun utilisateur connecté</h3>
                    <p style="color:#94a3b8;margin-bottom:20px;">
                        Aucun autre utilisateur n'est actuellement en ligne pour recevoir votre demande.
                    </p>
                    <p style="color:#64748b;font-size:0.85rem;margin-bottom:20px;">
                        Attendez que d'autres utilisateurs se connectent et réessayez.
                    </p>
                    <button id="close-modal-btn" class="btn btn-primary" style="padding:10px 30px;">
                        Compris
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            modal.querySelector('#close-modal-btn').onclick = () => modal.remove();
        }
    }

    function updateJoinRequestsList(roomId) {
        const requests = state.pendingJoinRequests.get(roomId) || [];
        elements.joinRequestsCount.textContent = requests.length;

        if (requests.length === 0) {
            elements.joinRequestsList.innerHTML = `
                <div style="color:#94a3b8;font-size:0.85rem;padding:10px;">
                    Aucune demande en attente
                </div>
            `;
            return;
        }

        elements.joinRequestsList.innerHTML = requests.map((request, index) => {
            const timeAgo = formatTimeAgo(request.timestamp);

            return `
                <div class="join-request-item">
                    <div style="flex:1;min-width:0;">
                        <div class="join-request-info">${escapeHtml(request.name)}</div>
                        <div class="join-request-time" style="font-size:0.7rem;color:#64748b;">${request.peerId}</div>
                        <div class="join-request-time">${timeAgo}</div>
                    </div>
                    <div class="join-request-actions">
                        <button class="btn reset-btn" style="width:auto;padding:6px 12px;" onclick="rejectJoinRequest('${roomId}', ${index})">
                            ✗
                        </button>
                    </div>
                </div>
            `;
        }).join('');
    }

    // Accept join request by validating peer ID
    function acceptJoinByPeerId() {
        if (!state.currentRoom) return;

        const inputPeerId = elements.acceptJoinIdInput.value.trim().toUpperCase();
        if (!inputPeerId) {
            showToast('Veuillez entrer l\'ID à accepter', 'warning');
            return;
        }

        const roomId = state.currentRoom.id;
        const requests = state.pendingJoinRequests.get(roomId) || [];

        // Find matching request
        const requestIndex = requests.findIndex(r => r.peerId === inputPeerId);
        if (requestIndex === -1) {
            showToast('Aucune demande avec cet ID', 'warning');
            return;
        }

        const request = requests[requestIndex];

        // Add user to room members (by username)
        if (!state.currentRoom.members.includes(request.name)) {
            state.currentRoom.members.push(request.name);

            // Update the room in state.privateRooms
            const roomIndex = state.privateRooms.findIndex(r => r.id === roomId);
            if (roomIndex > -1) {
                state.privateRooms[roomIndex] = state.currentRoom;
            }
            savePrivateRooms();
        }

        // Send approval to the requester via P2P
        const connection = state.connections.get(inputPeerId);
        if (connection && connection.conn.open) {
            connection.conn.send({
                type: 'join-approved',
                roomId: roomId,
                roomName: state.currentRoom.name,
                creatorUsername: state.currentRoom.creatorUsername,
                admins: state.currentRoom.admins
            });
        }

        // Remove request from pending
        requests.splice(requestIndex, 1);
        state.pendingJoinRequests.set(roomId, requests);

        elements.acceptJoinIdInput.value = '';
        updateJoinRequestsList(roomId);

        if (requests.length === 0) {
            elements.joinRequestsSection.style.display = 'none';
        }

        showToast(`${request.name} ajouté au salon !`, 'success');
    }

    window.rejectJoinRequest = function(roomId, index) {
        const requests = state.pendingJoinRequests.get(roomId);
        if (!requests || !requests[index]) return;

        const request = requests[index];

        // Send rejection via P2P
        const connection = state.connections.get(request.peerId);
        if (connection && connection.conn.open) {
            connection.conn.send({
                type: 'join-rejected',
                roomId: roomId,
                reason: 'Demande refusée'
            });
        }

        requests.splice(index, 1);
        state.pendingJoinRequests.set(roomId, requests);

        updateJoinRequestsList(roomId);

        if (requests.length === 0) {
            elements.joinRequestsSection.style.display = 'none';
        }

        showToast(`Demande de ${request.name} rejetée`, 'info');
    };

    // ============================================
    // FRIENDS SYSTEM (Username-based)
    // ============================================

    // Cache for connected users list to avoid unnecessary DOM updates
    let cachedUsersList = null;

    // Update list of all connected users (both sidebar and main tab)
    function updateConnectedUsersList(forceUpdate = false) {
        const sidebarContainer = elements.connectedUsersList;
        const mainContainer = elements.mainConnectedUsersList;
        const users = Array.from(state.connections.entries());

        // Create cache key based on users, friend status, and sent requests
        const currentCacheKey = users.map(([peerId, info]) => {
            const username = info.name || info.username || peerId;
            const isFriend = state.friends.includes(username);
            const hasSentRequest = state.friendRequestsSent.some(r => r.username === username);
            return `${peerId}:${isFriend}:${hasSentRequest}`;
        }).join('|');

        // Skip update if nothing changed (unless forced)
        if (!forceUpdate && cachedUsersList === currentCacheKey) {
            return;
        }

        cachedUsersList = currentCacheKey;

        elements.connectedUsersCount.textContent = users.length;

        if (users.length === 0) {
            const emptyMessageSidebar = `
                <div style="color:#64748b;font-size:0.85rem;text-align:center;padding:20px;">
                    Aucun utilisateur connecté
                </div>
            `;
            const emptyMessageMain = `
                <div style="color:#64748b;font-size:0.9rem;text-align:center;padding:40px;">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="margin-bottom:12px;">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <p>Aucun utilisateur connecté pour le moment</p>
                </div>
            `;
            if (sidebarContainer) sidebarContainer.innerHTML = emptyMessageSidebar;
            if (mainContainer) mainContainer.innerHTML = emptyMessageMain;
            return;
        }

        // Generate user cards for sidebar (compact)
        const sidebarHTML = users.map(([peerId, info]) => {
            const username = info.name || info.username || peerId;
            const isFriend = state.friends.includes(username);
            const hasSentRequest = state.friendRequestsSent.some(r => r.username === username);

            return `
                <div class="peer-item connected" data-peer-id="${peerId}" data-username="${escapeHtml(username)}">
                    <div class="peer-avatar">${username.charAt(0).toUpperCase()}</div>
                    <div class="peer-details" style="flex:1;min-width:0;">
                        <div class="peer-name" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(username)}</div>
                        <div class="peer-id" style="font-size:0.65rem;">${peerId}</div>
                    </div>
                    <div style="display:flex;gap:4px;align-items:center;">
                        ${isFriend ?
                            `<button class="btn btn-primary dm-friend-btn" style="width:auto;padding:4px 8px;font-size:0.7rem;" data-peer-id="${peerId}">
                                DM
                            </button>` :
                            hasSentRequest ?
                            `<span style="color:#fbbf24;font-size:0.7rem;">Envoyée</span>` :
                            `<button class="btn btn-primary send-friend-request-btn" style="width:auto;padding:4px 8px;font-size:0.7rem;" data-username="${escapeHtml(username)}" data-peer-id="${peerId}">
                                + Ami
                            </button>`
                        }
                    </div>
                </div>
            `;
        }).join('');

        // Generate user cards for main tab (larger cards)
        const mainHTML = users.map(([peerId, info]) => {
            const username = info.name || info.username || peerId;
            const isFriend = state.friends.includes(username);
            const hasSentRequest = state.friendRequestsSent.some(r => r.username === username);

            return `
                <div class="room-card user-card" data-peer-id="${peerId}" data-username="${escapeHtml(username)}" style="cursor:default;">
                    <div class="room-card-header">
                        <span class="room-card-name">${escapeHtml(username)}</span>
                        ${isFriend ?
                            `<span class="room-card-badge" style="background:rgba(34,197,94,0.2);color:#22c55e;">Ami</span>` :
                            `<span class="room-card-badge" style="background:rgba(99,179,237,0.2);color:#63b3ed;">En ligne</span>`
                        }
                    </div>
                    <div class="room-card-info" style="font-size:0.75rem;color:#64748b;">${peerId}</div>
                    <div style="display:flex;gap:8px;margin-top:12px;">
                        ${isFriend ?
                            `<button class="btn btn-primary dm-friend-btn" style="flex:1;padding:8px;" data-peer-id="${peerId}">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:4px;">
                                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                                </svg>
                                Message
                            </button>` :
                            hasSentRequest ?
                            `<span style="color:#fbbf24;font-size:0.85rem;padding:8px;">Demande envoyée</span>` :
                            `<button class="btn btn-primary send-friend-request-btn" style="flex:1;padding:8px;" data-username="${escapeHtml(username)}" data-peer-id="${peerId}">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:4px;">
                                    <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                                    <circle cx="8.5" cy="7" r="4"></circle>
                                    <line x1="20" y1="8" x2="20" y2="14"></line>
                                    <line x1="23" y1="11" x2="17" y2="11"></line>
                                </svg>
                                Ajouter en ami
                            </button>`
                        }
                    </div>
                </div>
            `;
        }).join('');

        if (sidebarContainer) sidebarContainer.innerHTML = sidebarHTML;
        if (mainContainer) mainContainer.innerHTML = mainHTML;

        // Add click listeners for friend request buttons (both containers)
        [sidebarContainer, mainContainer].forEach(container => {
            if (!container) return;

            container.querySelectorAll('.send-friend-request-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const username = btn.dataset.username;
                    const peerId = btn.dataset.peerId;
                    sendFriendRequest(username, peerId);
                });
            });

            container.querySelectorAll('.dm-friend-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const peerId = btn.dataset.peerId;
                    startDmWithFriend(peerId);
                });
            });
        });
    }

    // Send a friend request to another user
    function sendFriendRequest(username, peerId) {
        if (state.friends.includes(username)) {
            showToast(`${username} est déjà votre ami`, 'warning');
            return;
        }

        // Check if already sent a request
        if (state.friendRequestsSent.some(r => r.username === username)) {
            showToast(`Demande déjà envoyée à ${username}`, 'warning');
            return;
        }

        const connection = state.connections.get(peerId);
        if (!connection || !connection.conn.open) {
            showToast('Utilisateur non connecté', 'warning');
            return;
        }

        // Send friend request via P2P
        connection.conn.send({
            type: 'friend-request',
            fromUsername: state.myName,
            fromPeerId: state.myPeerId,
            timestamp: Date.now()
        });

        // Add to sent requests list
        state.friendRequestsSent.push({
            username: username,
            peerId: peerId,
            timestamp: Date.now()
        });
        saveFriendRequestsSent();

        showToast(`Demande d'ami envoyée à ${username}`, 'success');

        // Force update after a short delay to allow UI to respond
        setTimeout(() => updateConnectedUsersList(true), 100);
    }

    // Handle received friend request
    function handleFriendRequest(data) {
        const { fromUsername, fromPeerId, timestamp } = data;

        // Check if already friends
        if (state.friends.includes(fromUsername)) {
            return;
        }

        // Check if request already exists
        if (state.friendRequestsReceived.some(r => r.username === fromUsername)) {
            return;
        }

        // Add to pending requests
        state.friendRequestsReceived.push({
            username: fromUsername,
            peerId: fromPeerId,
            timestamp
        });
        saveFriendRequests();
        updateFriendRequestsList();

        showToast(`${fromUsername} veut devenir votre ami`, 'info');
    }

    // Update friend requests list
    function updateFriendRequestsList() {
        const requests = state.friendRequestsReceived;
        const container = elements.friendRequestsList;
        const section = elements.friendRequestsSection;

        if (requests.length === 0) {
            section.style.display = 'none';
            return;
        }

        section.style.display = 'block';
        elements.friendRequestsCount.textContent = requests.length;

        container.innerHTML = requests.map((request, index) => {
            const timeAgo = formatTimeAgo(request.timestamp);
            return `
                <div class="friend-request-item" style="display:flex;align-items:center;gap:8px;padding:8px;background:rgba(30,41,59,0.5);border-radius:8px;margin-bottom:6px;">
                    <div style="flex:1;min-width:0;">
                        <div style="color:#e2e8f0;font-size:0.85rem;font-weight:500;">${escapeHtml(request.username)}</div>
                        <div style="color:#64748b;font-size:0.7rem;">${timeAgo}</div>
                    </div>
                    <button class="btn btn-danger" style="width:auto;padding:4px 8px;font-size:0.7rem;" onclick="rejectFriendRequest(${index})">✗</button>
                </div>
            `;
        }).join('');
    }

    // Accept friend request by validating peer ID
    function acceptFriendByPeerId() {
        const inputPeerId = elements.acceptFriendIdInput.value.trim().toUpperCase();
        if (!inputPeerId) {
            showToast('Veuillez entrer l\'ID à valider', 'warning');
            return;
        }

        // Find matching request
        const requestIndex = state.friendRequestsReceived.findIndex(r => r.peerId === inputPeerId);
        if (requestIndex === -1) {
            showToast('Aucune demande avec cet ID', 'warning');
            return;
        }

        const request = state.friendRequestsReceived[requestIndex];

        // Add to friends (by username)
        if (!state.friends.includes(request.username)) {
            state.friends.push(request.username);
            saveFriends();
        }

        // Remove from pending requests
        state.friendRequestsReceived.splice(requestIndex, 1);
        saveFriendRequests();

        // Send confirmation to the requester
        const connection = state.connections.get(inputPeerId);
        if (connection && connection.conn.open) {
            connection.conn.send({
                type: 'friend-accepted',
                fromUsername: state.myName,
                fromPeerId: state.myPeerId
            });
        }

        elements.acceptFriendIdInput.value = '';
        updateFriendRequestsList();
        updateFriendsList();
        updateConnectedUsersList(true);

        showToast(`${request.username} ajouté à vos amis !`, 'success');
    }

    // Handle when our friend request is accepted
    function handleFriendAccepted(data) {
        const { fromUsername, fromPeerId } = data;

        if (!state.friends.includes(fromUsername)) {
            state.friends.push(fromUsername);
            saveFriends();
            updateFriendsList();
            updateConnectedUsersList(true);
        }

        // Remove from sent requests list
        const sentIndex = state.friendRequestsSent.findIndex(r => r.username === fromUsername);
        if (sentIndex > -1) {
            state.friendRequestsSent.splice(sentIndex, 1);
            saveFriendRequestsSent();
        }

        showToast(`${fromUsername} a accepté votre demande d'ami !`, 'success');
    }

    // Reject friend request
    window.rejectFriendRequest = function(index) {
        if (index >= 0 && index < state.friendRequestsReceived.length) {
            const request = state.friendRequestsReceived[index];
            state.friendRequestsReceived.splice(index, 1);
            saveFriendRequests();
            updateFriendRequestsList();
            showToast(`Demande de ${request.username} refusée`, 'info');
        }
    };

    // Remove friend (by username)
    function removeFriend(username) {
        const index = state.friends.indexOf(username);
        if (index > -1) {
            state.friends.splice(index, 1);
            saveFriends();
            updateFriendsList();
            updateConnectedUsersList(true);
            showToast('Ami supprimé', 'info');
        }
    }

    // Update friends list (by username)
    function updateFriendsList() {
        const friends = state.friends;
        const container = elements.friendsList;

        if (friends.length === 0) {
            container.innerHTML = `
                <div style="color:#64748b;font-size:0.85rem;text-align:center;padding:20px;">
                    Aucun ami
                </div>
            `;
            return;
        }

        container.innerHTML = friends.map(username => {
            // Find connection by username
            let connectionPeerId = null;
            let isOnline = false;
            for (const [peerId, info] of state.connections) {
                if (info.name === username || info.username === username) {
                    connectionPeerId = peerId;
                    isOnline = info.conn && info.conn.open;
                    break;
                }
            }

            return `
                <div class="friend-item ${isOnline ? '' : 'offline'}" data-username="${escapeHtml(username)}" data-peer-id="${connectionPeerId || ''}">
                    <div class="friend-status ${isOnline ? 'online' : ''}"></div>
                    <span class="friend-name">${escapeHtml(username)}</span>
                    <div style="display:flex;gap:4px;align-items:center;">
                        ${isOnline ?
                            `<button class="btn btn-primary dm-friend-btn" style="width:auto;padding:4px 8px;font-size:0.7rem;">
                                DM
                            </button>` :
                            `<span style="color:#64748b;font-size:0.7rem;">Hors ligne</span>`
                        }
                        <button class="btn btn-danger remove-friend-btn" style="width:auto;padding:4px 6px;font-size:0.65rem;" title="Supprimer">✗</button>
                    </div>
                </div>
            `;
        }).join('');

        // Add click listeners
        container.querySelectorAll('.friend-item').forEach(item => {
            const username = item.dataset.username;
            const peerId = item.dataset.peerId;

            const dmBtn = item.querySelector('.dm-friend-btn');
            if (dmBtn) {
                dmBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (peerId) startDmWithFriend(peerId);
                });
            }

            const removeBtn = item.querySelector('.remove-friend-btn');
            if (removeBtn) {
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm(`Supprimer ${username} de vos amis ?`)) {
                        removeFriend(username);
                    }
                });
            }

            // Click on item to start DM
            item.addEventListener('click', (e) => {
                if (e.target.tagName !== 'BUTTON' && peerId) {
                    const connection = state.connections.get(peerId);
                    if (connection && connection.conn.open) {
                        startDmWithFriend(peerId);
                    }
                }
            });
        });
    }

    window.startDmWithFriend = function(peerId) {
        const connection = state.connections.get(peerId);
        if (!connection) {
            showToast('Non connecté à cet ami', 'warning');
            return;
        }

        switchTab('dm');
        openDmConversation(peerId);
    };

    function saveFriends() {
        localStorage.setItem('friends', JSON.stringify(state.friends));
    }

    function saveFriendRequests() {
        localStorage.setItem('friendRequestsReceived', JSON.stringify(state.friendRequestsReceived));
    }

    function saveFriendRequestsSent() {
        localStorage.setItem('friendRequestsSent', JSON.stringify(state.friendRequestsSent));
    }

    // ============================================
    // DIRECT MESSAGES SYSTEM
    // ============================================

    function toggleDmSettings() {
        state.allowDMFromNonFriends = !state.allowDMFromNonFriends;
        localStorage.setItem('allowDMFromNonFriends', state.allowDMFromNonFriends);

        const toggle = elements.acceptDMToggle.querySelector('.toggle-input');
        toggle.classList.toggle('active', state.allowDMFromNonFriends);

        showToast(state.allowDMFromNonFriends ?
            'Messages de non-amis autorisés' :
            'Seuls les amis peuvent vous envoyer des messages',
        'info');
    }

    // ID Generation settings
    function initAutoGenerateIdUI() {
        const toggle = elements.autoGenerateIdToggle.querySelector('.toggle-input');
        toggle.classList.toggle('active', state.autoGenerateId);
        elements.regenerateIdBtn.style.display = state.autoGenerateId ? 'none' : 'flex';
    }

    function toggleAutoGenerateId() {
        state.autoGenerateId = !state.autoGenerateId;
        localStorage.setItem('autoGenerateId', state.autoGenerateId);

        const toggle = elements.autoGenerateIdToggle.querySelector('.toggle-input');
        toggle.classList.toggle('active', state.autoGenerateId);

        // Show/hide regenerate button
        elements.regenerateIdBtn.style.display = state.autoGenerateId ? 'none' : 'flex';

        if (!state.autoGenerateId) {
            // Switching to fixed ID mode - save current ID
            state.savedPeerId = state.myPeerId;
            localStorage.setItem('savedPeerId', state.myPeerId);
            showToast('ID fixe activé. Votre ID restera le même entre les sessions.', 'info');
        } else {
            // Switching to auto-generate mode
            showToast('Génération automatique activée. Un nouvel ID sera généré au prochain rafraîchissement.', 'info');
        }
    }

    function regenerateUserId() {
        if (state.autoGenerateId) {
            showToast('La génération automatique est activée. Rafraîchissez la page pour un nouvel ID.', 'warning');
            return;
        }

        if (!confirm('Êtes-vous sûr de vouloir générer un nouvel ID ?\n\nVos contacts devront utiliser ce nouvel ID pour vous trouver.')) {
            return;
        }

        // Generate new ID
        const newPeerId = 'PT-' + generateId(8);
        state.savedPeerId = newPeerId;
        localStorage.setItem('savedPeerId', newPeerId);

        showToast('Nouvel ID généré. Rafraîchissez la page pour l\'appliquer.', 'success');
        showToast('Actualisez la page pour utiliser le nouvel ID.', 'warning');
    }

    function updateDmContactsList() {
        // Get all contacts we have DMs with
        const contacts = Array.from(state.directMessages.keys());
        
        const container = elements.dmContactsList;

        if (contacts.length === 0) {
            container.innerHTML = `
                <div style="color:#64748b;font-size:0.9rem;text-align:center;padding:40px;">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="margin-bottom:12px;">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    <p>Aucune conversation. Ajoutez des amis depuis la barre latérale.</p>
                </div>
            `;
            return;
        }

        container.innerHTML = contacts.map(peerId => {
            const connection = state.connections.get(peerId);
            const isOnline = connection && connection.conn.open;
            const name = connection ? connection.name : (peerId || 'Unknown');
            const initial = name ? name.charAt(0).toUpperCase() : '?';
            const messages = state.directMessages.get(peerId) || [];
            const lastMessage = messages[messages.length - 1];
            const unreadCount = messages.filter(m => !m.fromMe && !m.read).length;

            return `
                <div class="dm-contact" data-peer-id="${peerId}">
                    <div class="dm-contact-avatar">${escapeHtml(initial)}</div>
                    <div class="dm-contact-info">
                        <div class="dm-contact-name">${escapeHtml(name)}</div>
                        <div class="dm-contact-status">${isOnline ? 'En ligne' : 'Hors ligne'}</div>
                    </div>
                    ${unreadCount > 0 ? `<div class="dm-contact-unread">${unreadCount}</div>` : ''}
                    <button class="dm-delete-btn" data-peer-id="${peerId}" title="Supprimer la conversation">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                        </svg>
                    </button>
                </div>
            `;
        }).join('');

        // Add click listeners for contacts
        container.querySelectorAll('.dm-contact').forEach(contact => {
            contact.addEventListener('click', (e) => {
                if (!e.target.closest('.dm-delete-btn')) {
                    openDmConversation(contact.dataset.peerId);
                }
            });
        });

        // Add click listeners for delete buttons
        container.querySelectorAll('.dm-delete-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteDmConversation(btn.dataset.peerId);
            });
        });
    }

    function deleteDmConversation(peerId) {
        const connection = state.connections.get(peerId);
        const name = connection ? connection.name : peerId;

        if (!confirm(`Êtes-vous sûr de vouloir supprimer la conversation avec ${name} ?`)) return;

        state.directMessages.delete(peerId);
        saveDirectMessages();
        updateDmContactsList();

        // Si c'est la conversation actuelle, revenir à la liste
        if (state.activeDMConversation === peerId) {
            backToDmList();
        }

        showToast('Conversation supprimée', 'success');
    }

    function openDmConversation(peerId) {
        state.activeDMConversation = peerId;

        const connection = state.connections.get(peerId);
        const name = connection ? connection.name : peerId;

        elements.dmContactName.textContent = name;

        // Show conversation, hide list
        elements.dmContactsList.style.display = 'none';
        elements.dmConversation.style.display = 'block';

        // Load messages
        const messages = state.directMessages.get(peerId) || [];
        renderDmMessages(messages);

        // Mark as read
        messages.forEach(m => { if (!m.fromMe) m.read = true; });
        state.directMessages.set(peerId, messages);
        saveDirectMessages();

        elements.dmInput.focus();
        
        // Show toast to confirm connection
        if (connection && connection.conn.open) {
            showToast(`Conversation avec ${name} prête`, 'success');
        }
    }

    function backToDmList() {
        state.activeDMConversation = null;
        elements.dmContactsList.style.display = 'block';
        elements.dmConversation.style.display = 'none';
        updateDmContactsList();
    }

    function renderDmMessages(messages) {
        elements.dmMessages.innerHTML = '';

        if (messages.length === 0) {
            elements.dmMessages.innerHTML = `<div class="message system">Début de la conversation privée</div>`;
            return;
        }

        messages.forEach(msg => {
            appendDmMessage(msg.content, msg.fromMe, msg.timestamp);
        });

        scrollToBottom(elements.dmMessages);
    }

    function appendDmMessage(content, fromMe, timestamp = Date.now()) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${fromMe ? 'sent' : 'received'}`;

        const timeStr = new Date(timestamp).toLocaleTimeString('fr-FR', {
            hour: '2-digit',
            minute: '2-digit'
        });

        messageDiv.innerHTML = `
            <div class="message-content">${escapeHtml(content)}</div>
            <div class="message-time">${timeStr}</div>
        `;

        elements.dmMessages.appendChild(messageDiv);
        scrollToBottom(elements.dmMessages);
    }

    async function sendDirectMessage() {
        if (!state.activeDMConversation) return;

        const content = elements.dmInput.value.trim();
        if (!content) return;

        const peerId = state.activeDMConversation;
        const connection = state.connections.get(peerId);

        if (!connection || !connection.conn.open) {
            showToast('Non connecté à ce contact', 'warning');
            return;
        }

        // Encrypt and send message
        const encrypted = await Crypto.encrypt(connection.sharedKey, content);

        connection.conn.send({
            type: 'dm',
            encrypted: encrypted,
            from: state.myName,
            to: connection.name || 'Inconnu'
        });

        // Store locally
        const messages = state.directMessages.get(peerId) || [];
        messages.push({
            content,
            timestamp: Date.now(),
            fromMe: true,
            read: true
        });
        state.directMessages.set(peerId, messages);
        saveDirectMessages();

        // Display
        appendDmMessage(content, true, Date.now());

        elements.dmInput.value = '';
    }

    function saveDirectMessages() {
        const data = Array.from(state.directMessages.entries()).map(([peerId, msgs]) => ({
            peerId,
            messages: msgs
        }));
        localStorage.setItem('directMessages', JSON.stringify(data));
    }

    function loadDirectMessages() {
        const data = JSON.parse(localStorage.getItem('directMessages') || '[]');
        data.forEach(({ peerId, messages }) => {
            state.directMessages.set(peerId, messages);
        });
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    function savePrivateRooms() {
        localStorage.setItem('privateRooms', JSON.stringify(state.privateRooms));
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function formatTimeAgo(timestamp) {
        const seconds = Math.floor((Date.now() - timestamp) / 1000);

        if (seconds < 60) return "À l'instant";
        if (seconds < 3600) return `Il y a ${Math.floor(seconds / 60)} min`;
        if (seconds < 86400) return `Il y a ${Math.floor(seconds / 3600)} h`;
        return `Il y a ${Math.floor(seconds / 86400)} j`;
    }

    function scrollToBottom(container) {
        if (container && container.scrollHeight !== undefined) {
            container.scrollTop = container.scrollHeight;
        }
    }

    // ============================================
    // MESSAGE HANDLERS FOR NEW FEATURES
    // ============================================

    function handleJoinRequest(data) {
        // Handler for when someone requests to join a room
        // In real implementation, this would be called from the P2P message handler
        const { peerId, name, roomId } = data;

        const room = state.privateRooms.find(r => r.id === roomId);
        if (!room) return;

        // Only creator/admins receive join requests (by username)
        const isAdmin = room.creatorUsername === state.myName || room.admins.includes(state.myName);
        if (!isAdmin) return;

        // Add to pending requests
        const requests = state.pendingJoinRequests.get(roomId) || [];
        requests.push({
            peerId,
            name,
            timestamp: Date.now()
        });
        state.pendingJoinRequests.set(roomId, requests);

        if (state.currentRoom && state.currentRoom.id === roomId) {
            elements.joinRequestsSection.style.display = 'block';
            updateJoinRequestsList(roomId);
        }

        showToast(`${name} souhaite rejoindre le salon`, 'info');
    }

    function handleJoinApproved(data) {
        // Handler for when our join request is approved
        const { roomId, roomName, creatorUsername, admins } = data;

        const room = {
            id: roomId,
            name: roomName,
            creatorUsername,
            admins,
            members: [state.myName],  // Stockage par nom d'utilisateur
            createdAt: Date.now()
        };

        state.privateRooms.push(room);
        savePrivateRooms();
        updatePrivateRoomsList();

        showToast(`Demande approuvée ! Vous avez rejoint "${roomName}"`, 'success');
        showRoomDetail(room);
    }

    function handleJoinRejected(data) {
        // Handler for when our join request is rejected
        const { roomId, reason } = data;
        showToast(`Demande refusée : ${reason || 'Accès refusé'}`, 'warning');
    }

    async function handleDirectMessage(data) {
        const { encrypted, from } = data;

        // Find the connection that sent this message
        let senderConnection = null;
        let senderPeerId = null;

        for (const [peerId, connectionInfo] of state.connections) {
            if (connectionInfo.name === from) {
                senderConnection = connectionInfo;
                senderPeerId = peerId;
                break;
            }
        }

        if (!senderConnection || !senderConnection.conn.open) {
            console.error('No connection found for DM sender:', from);
            return;
        }

        // Check if we allow DMs from this sender
        const isFriend = state.friends.includes(from);
        if (!state.allowDMFromNonFriends && !isFriend) {
            // Send rejection
            senderConnection.conn.send({
                type: 'dmRejected',
                reason: 'DM restricted to friends only'
            });
            return;
        }

        try {
            const content = await Crypto.decrypt(senderConnection.sharedKey, encrypted);

            // Store message
            const messages = state.directMessages.get(senderPeerId) || [];
            messages.push({
                content,
                timestamp: Date.now(),
                fromMe: false,
                read: !state.activeDMConversation || state.activeDMConversation !== senderPeerId
            });
            state.directMessages.set(senderPeerId, messages);
            saveDirectMessages();

            // Update UI
            if (state.activeDMConversation === senderPeerId) {
                appendDmMessage(content, false, Date.now());
                // Send read receipt
                senderConnection.conn.send({ 
                    type: 'dmRead',
                    from: state.myName
                });
            }

            updateDmContactsList();
            showToast(`Message de ${from}`, 'info');

        } catch (err) {
            console.error('Error decrypting DM:', err);
        }
    }

    function handleDmRejected(data) {
        showToast(`Message rejeté: ${data.reason}`, 'warning');
    }

    function handleDmRead(data) {
        // Mark messages as read
        const peerId = data.peerId;
        const messages = state.directMessages.get(peerId) || [];
        messages.forEach(m => { if (!m.fromMe) m.read = true; });
        state.directMessages.set(peerId, messages);
        saveDirectMessages();
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', init);

    // Cleanup
    window.addEventListener('beforeunload', () => {
        state.connections.forEach(({ conn }) => conn.close());
        if (state.peer) state.peer.destroy();
    });

    // Expose connect function for manual connection
    window.connectToPeer = connectToPeer;

    // ============================================
    // NEW FEATURES IMPLEMENTATION
    // ============================================

    // PWA: Register Service Worker (only on HTTPS or localhost)
    if ('serviceWorker' in navigator && (location.protocol === 'https:' || location.hostname === 'localhost')) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js')
                .then(reg => console.log('✅ Service Worker enregistré:', reg.scope))
                .catch(err => console.warn('⚠️ Service Worker:', err.message));
        });
    } else if (location.protocol === 'file:') {
        console.log('ℹ️ Service Worker désactivé en mode fichier local (ouvrez via serveur HTTP)');
    }

    // Share API Support
    const shareIdBtn = document.getElementById('share-id-btn');
    if (navigator.share) {
        shareIdBtn.style.display = 'inline-flex';
        shareIdBtn.addEventListener('click', async () => {
            try {
                await navigator.share({
                    title: 'Mon ID PeerText',
                    text: `Connecte-toi avec moi sur PeerText! Mon ID: ${state.myPeerId}`,
                    url: window.location.href
                });
                showToast('ID partagé avec succès!', 'success');
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Erreur partage:', err);
                }
            }
        });
    }

    // Vibration API for notifications (mobile)
    function vibrateNotification() {
        if ('vibrate' in navigator) {
            navigator.vibrate([200, 100, 200]);
        }
    }

    // Drag & Drop File Upload
    const dragDropOverlay = document.getElementById('drag-drop-overlay');
    let dragCounter = 0;

    document.addEventListener('dragenter', (e) => {
        e.preventDefault();
        dragCounter++;
        if (dragCounter === 1) {
            dragDropOverlay.classList.add('active');
        }
    });

    document.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dragCounter--;
        if (dragCounter === 0) {
            dragDropOverlay.classList.remove('active');
        }
    });

    document.addEventListener('dragover', (e) => {
        e.preventDefault();
    });

    document.addEventListener('drop', (e) => {
        e.preventDefault();
        dragCounter = 0;
        dragDropOverlay.classList.remove('active');

        const files = e.dataTransfer.files;
        if (files.length > 0 && state.currentRoom) {
            const file = files[0];
            elements.fileInput.files = files;
            handleFileSelect({ target: elements.fileInput });
        }
    });

    // Lazy Loading for Images
    function createLazyImage(src, alt = 'Image') {
        const placeholder = document.createElement('div');
        placeholder.className = 'image-placeholder loading';

        const img = new Image();
        img.className = 'image-preview';
        img.alt = alt;
        img.loading = 'lazy';

        img.onload = () => {
            placeholder.replaceWith(img);
        };

        img.onerror = () => {
            placeholder.textContent = '❌ Erreur chargement image';
            placeholder.classList.remove('loading');
        };

        // Load image when in viewport
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    img.src = src;
                    observer.unobserve(placeholder);
                }
            });
        });

        observer.observe(placeholder);
        return placeholder;
    }

    // Enhanced E2E Indicator
    const e2eIndicator = document.getElementById('e2e-indicator');
    function updateE2EIndicator() {
        if (state.currentRoom && state.connections.size > 0) {
            const allEncrypted = Array.from(state.connections.values())
                .every(conn => conn.sharedKey);
            if (allEncrypted) {
                e2eIndicator.classList.add('active');
                vibrateNotification(); // Vibrate when E2E is established
            } else {
                e2eIndicator.classList.remove('active');
            }
        } else {
            e2eIndicator.classList.remove('active');
        }
    }

    // Auto-delete messages after time
    const MESSAGE_LIFETIME = 24 * 60 * 60 * 1000; // 24 hours

    function cleanOldMessages() {
        const now = Date.now();
        state.directMessages.forEach((messages, peerId) => {
            const filtered = messages.filter(msg => {
                if (msg.timestamp && (now - msg.timestamp > MESSAGE_LIFETIME)) {
                    return false; // Delete old message
                }
                return true;
            });
            state.directMessages.set(peerId, filtered);
        });
        saveDirectMessages();
    }

    // Run cleanup on init and periodically
    setInterval(cleanOldMessages, 60 * 60 * 1000); // Every hour

    // Enhanced reconnection with exponential backoff
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;

    function reconnectWithBackoff(peerId) {
        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
            console.log('❌ Maximum de tentatives de reconnexion atteint');
            showToast('Impossible de se reconnecter après plusieurs tentatives', 'error');
            reconnectAttempts = 0;
            return;
        }

        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
        reconnectAttempts++;

        console.log(`🔄 Tentative de reconnexion ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} dans ${delay}ms...`);

        setTimeout(() => {
            connectToPeer(peerId);
        }, delay);
    }

    // File transfer with retry
    const fileTransferRetries = new Map();
    const MAX_FILE_RETRIES = 3;

    function retryFileTransfer(transferId, chunkIndex) {
        const retries = fileTransferRetries.get(transferId) || 0;

        if (retries >= MAX_FILE_RETRIES) {
            showToast('Échec du transfert après plusieurs tentatives', 'error');
            fileTransferRetries.delete(transferId);
            return false;
        }

        fileTransferRetries.set(transferId, retries + 1);
        return true;
    }

    // Mobile gestures (swipe to reply)
    let touchStartX = 0;
    let touchStartY = 0;
    let swipingMessage = null;

    elements.messagesContainer.addEventListener('touchstart', (e) => {
        const message = e.target.closest('.message');
        if (message && !message.classList.contains('system')) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            swipingMessage = message;
        }
    });

    elements.messagesContainer.addEventListener('touchmove', (e) => {
        if (!swipingMessage) return;

        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const deltaX = touchX - touchStartX;
        const deltaY = touchY - touchStartY;

        // Only horizontal swipe
        if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX > 30) {
            swipingMessage.classList.add('swiping');
        }
    });

    elements.messagesContainer.addEventListener('touchend', (e) => {
        if (!swipingMessage) return;

        if (swipingMessage.classList.contains('swiping')) {
            // Trigger reply action
            const sender = swipingMessage.querySelector('.message-sender')?.textContent;
            if (sender) {
                elements.messageInput.value = `@${sender} `;
                elements.messageInput.focus();
                vibrateNotification();
            }
        }

        swipingMessage.classList.remove('swiping');
        swipingMessage = null;
    });

    // Enhanced keyboard navigation
    document.addEventListener('keydown', (e) => {
        // Escape to close modals
        if (e.key === 'Escape') {
            if (elements.settingsModal.classList.contains('show')) {
                closeSettingsModal();
            }
            if (elements.imageModal.classList.contains('show')) {
                elements.imageModal.classList.remove('show');
            }
        }

        // Alt + 1/2/3 to switch tabs
        if (e.altKey) {
            if (e.key === '1') {
                e.preventDefault();
                switchTab('rooms');
            } else if (e.key === '2') {
                e.preventDefault();
                switchTab('users');
            } else if (e.key === '3') {
                e.preventDefault();
                switchTab('dm');
            }
        }
    });

    // Update E2E indicator when connections change
    const originalHandleIncomingConnection = handleIncomingConnection;
    handleIncomingConnection = function(...args) {
        const result = originalHandleIncomingConnection.apply(this, args);
        setTimeout(updateE2EIndicator, 1000);
        return result;
    };

    console.log('✅ Toutes les améliorations sont activées!');
    </script>

    <!-- Drag & Drop Overlay -->
    <div class="drag-drop-overlay" id="drag-drop-overlay">
        <div class="drag-drop-content">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
            <h3>Déposez votre fichier ici</h3>
            <p>Le fichier sera envoyé de manière sécurisée</p>
        </div>
    </div>

</body>
</html>
